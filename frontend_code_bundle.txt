===== BEGIN FILE: index.html =====
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google-site-verification" content="j8eq-Lj1onJN7wj-wOgZ1EPlIiEzvDfY_X_fkmdkUyw" />
    <title>Free Cluely</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

===== END FILE: index.html =====

===== BEGIN FILE: renderer\public\index.html =====
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

===== END FILE: renderer\public\index.html =====

===== BEGIN FILE: renderer\src\App.css =====
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

===== END FILE: renderer\src\App.css =====

===== BEGIN FILE: renderer\src\App.test.tsx =====
import React from 'react';
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

===== END FILE: renderer\src\App.test.tsx =====

===== BEGIN FILE: renderer\src\App.tsx =====
import React from 'react';
import logo from './logo.svg';
import './App.css';

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>
          Edit <code>src/App.tsx</code> and save to reload.
        </p>
        <a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn React
        </a>
      </header>
    </div>
  );
}

export default App;

===== END FILE: renderer\src\App.tsx =====

===== BEGIN FILE: renderer\src\index.css =====
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

===== END FILE: renderer\src\index.css =====

===== BEGIN FILE: renderer\src\index.tsx =====
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

===== END FILE: renderer\src\index.tsx =====

===== BEGIN FILE: renderer\src\react-app-env.d.ts =====
/// <reference types="react-scripts" />

===== END FILE: renderer\src\react-app-env.d.ts =====

===== BEGIN FILE: renderer\src\reportWebVitals.ts =====
import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

===== END FILE: renderer\src\reportWebVitals.ts =====

===== BEGIN FILE: renderer\src\setupTests.ts =====
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

===== END FILE: renderer\src\setupTests.ts =====

===== BEGIN FILE: src\App.tsx =====
import { ToastProvider, ToastViewport } from "./components/ui/toast"
import Queue from "./_pages/Queue"
import { useEffect, useRef, useState } from "react"
import Solutions from "./_pages/Solutions"
import { QueryClient, QueryClientProvider } from "react-query"

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: Infinity,
      cacheTime: Infinity
    }
  }
})

const App: React.FC = () => {
  const [view, setView] = useState<"queue" | "solutions" | "debug">("queue")
  const containerRef = useRef<HTMLDivElement>(null)
  const lastSizeRef = useRef<{ w: number; h: number }>({ w: 0, h: 0 })
  const debounceRef = useRef<number | null>(null)

  // Effect for height monitoring
  useEffect(() => {
    const cleanup = window.electronAPI.onResetView(() => {
      console.log("Received 'reset-view' message from main process.")
      queryClient.invalidateQueries(["screenshots"])
      queryClient.invalidateQueries(["problem_statement"])
      queryClient.invalidateQueries(["solution"])
      queryClient.invalidateQueries(["new_solution"])
      setView("queue")
    })

    return () => {
      cleanup()
    }
  }, [])

  // Removed global sizing effect to avoid fighting with page-level sizing.
  // Queue and Solutions pages now own window sizing, including the fixed toolbar width.

  useEffect(() => {
    const cleanupFunctions = [
      window.electronAPI.onSolutionStart(() => {
        // Stay on Queue; the Queue page shows a modern solution panel
        console.log("starting processing")
      }),

      window.electronAPI.onUnauthorized(() => {
        queryClient.removeQueries(["screenshots"])
        queryClient.removeQueries(["solution"])
        queryClient.removeQueries(["problem_statement"])
        setView("queue")
        console.log("Unauthorized")
      }),
      // Update this reset handler
      window.electronAPI.onResetView(() => {
        console.log("Received 'reset-view' message from main process")

        queryClient.removeQueries(["screenshots"])
        queryClient.removeQueries(["solution"])
        queryClient.removeQueries(["problem_statement"])
        setView("queue")
        console.log("View reset to 'queue' via Command+R shortcut")
      }),
      window.electronAPI.onProblemExtracted((data: any) => {
        if (view === "queue") {
          console.log("Problem extracted successfully")
          queryClient.invalidateQueries(["problem_statement"])
          queryClient.setQueryData(["problem_statement"], data)
        }
      })
    ]
    return () => cleanupFunctions.forEach((cleanup) => cleanup())
  }, [])

  return (
    <div ref={containerRef} className="min-h-0 inline-block w-fit">
      <QueryClientProvider client={queryClient}>
        <ToastProvider>
          {view === "queue" ? (
            <Queue setView={setView} />
          ) : view === "solutions" ? (
            <Solutions setView={setView} />
          ) : (
            <></>
          )}
          <ToastViewport />
        </ToastProvider>
      </QueryClientProvider>
    </div>
  )
}

export default App

===== END FILE: src\App.tsx =====

===== BEGIN FILE: src\_pages\Debug.tsx =====
// Debug.tsx
import React, { useState, useEffect, useRef } from "react"
import { useQuery, useQueryClient } from "react-query"
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter"
import { dracula } from "react-syntax-highlighter/dist/esm/styles/prism"
import { ComplexitySection, ContentSection } from "./Solutions"
import ScreenshotQueue from "../components/Queue/ScreenshotQueue"
import {
  Toast,
  ToastDescription,
  ToastMessage,
  ToastTitle,
  ToastVariant
} from "../components/ui/toast"
import ExtraScreenshotsQueueHelper from "../components/Solutions/SolutionCommands"
import { diffLines } from "diff"

type DiffLine = {
  value: string
  added?: boolean
  removed?: boolean
}

const syntaxHighlighterStyles = {
  ".syntax-line": {
    whiteSpace: "pre-wrap",
    wordBreak: "break-word",
    overflowWrap: "break-word"
  }
} as const

const CodeComparisonSection = ({
  oldCode,
  newCode,
  isLoading
}: {
  oldCode: string | null
  newCode: string | null
  isLoading: boolean
}) => {
  const computeDiff = () => {
    if (!oldCode || !newCode) return { leftLines: [], rightLines: [] }

    // Normalize line endings and clean up the code
    const normalizeCode = (code: string) => {
      return code
        .replace(/\r\n/g, "\n") // Convert Windows line endings to Unix
        .replace(/\r/g, "\n") // Convert remaining carriage returns
        .trim() // Remove leading/trailing whitespace
    }

    const normalizedOldCode = normalizeCode(oldCode)
    const normalizedNewCode = normalizeCode(newCode)

    // Generate the diff
    const diff = diffLines(normalizedOldCode, normalizedNewCode, {
      newlineIsToken: true,
      ignoreWhitespace: true // Changed to true to better handle whitespace differences
    })

    // Process the diff to create parallel arrays
    const leftLines: DiffLine[] = []
    const rightLines: DiffLine[] = []

    diff.forEach((part) => {
      if (part.added) {
        // Add empty lines to left side
        leftLines.push(...Array(part.count || 0).fill({ value: "" }))
        // Add new lines to right side, filter out empty lines at the end
        rightLines.push(
          ...part.value
            .split("\n")
            .filter((line) => line.length > 0)
            .map((line) => ({
              value: line,
              added: true
            }))
        )
      } else if (part.removed) {
        // Add removed lines to left side, filter out empty lines at the end
        leftLines.push(
          ...part.value
            .split("\n")
            .filter((line) => line.length > 0)
            .map((line) => ({
              value: line,
              removed: true
            }))
        )
        // Add empty lines to right side
        rightLines.push(...Array(part.count || 0).fill({ value: "" }))
      } else {
        // Add unchanged lines to both sides
        const lines = part.value.split("\n").filter((line) => line.length > 0)
        leftLines.push(...lines.map((line) => ({ value: line })))
        rightLines.push(...lines.map((line) => ({ value: line })))
      }
    })

    return { leftLines, rightLines }
  }

  const { leftLines, rightLines } = computeDiff()

  return (
    <div className="space-y-1.5">
      <h2 className="text-[13px] font-medium text-white tracking-wide">
        Code Comparison
      </h2>
      {isLoading ? (
        <div className="space-y-1">
          <div className="mt-3 flex">
            <p className="text-xs bg-gradient-to-r from-gray-300 via-gray-100 to-gray-300 bg-clip-text text-transparent animate-pulse">
              Loading code comparison...
            </p>
          </div>
        </div>
      ) : (
        <div className="flex flex-row gap-0.5 bg-[#161b22] rounded-lg overflow-hidden">
          {/* Previous Code */}
          <div className="w-1/2 border-r border-gray-700">
            <div className="bg-[#2d333b] px-3 py-1.5">
              <h3 className="text-[11px] font-medium text-gray-200">
                Previous Version
              </h3>
            </div>
            <div className="p-3 overflow-x-auto">
              <SyntaxHighlighter
                language="python"
                style={dracula}
                customStyle={{
                  maxWidth: "100%",
                  margin: 0,
                  padding: "1rem",
                  whiteSpace: "pre-wrap",
                  wordBreak: "break-all"
                }}
                wrapLines={true}
                showLineNumbers={true}
                lineProps={(lineNumber) => {
                  const line = leftLines[lineNumber - 1]
                  return {
                    style: {
                      display: "block",
                      backgroundColor: line?.removed
                        ? "rgba(139, 0, 0, 0.2)"
                        : "transparent"
                    }
                  }
                }}
              >
                {leftLines.map((line) => line.value).join("\n")}
              </SyntaxHighlighter>
            </div>
          </div>

          {/* New Code */}
          <div className="w-1/2">
            <div className="bg-[#2d333b] px-3 py-1.5">
              <h3 className="text-[11px] font-medium text-gray-200">
                New Version
              </h3>
            </div>
            <div className="p-3 overflow-x-auto">
              <SyntaxHighlighter
                language="python"
                style={dracula}
                customStyle={{
                  maxWidth: "100%",
                  margin: 0,
                  padding: "1rem",
                  whiteSpace: "pre-wrap",
                  wordBreak: "break-all"
                }}
                wrapLines={true}
                showLineNumbers={true}
                lineProps={(lineNumber) => {
                  const line = rightLines[lineNumber - 1]
                  return {
                    style: {
                      display: "block",
                      backgroundColor: line?.added
                        ? "rgba(0, 139, 0, 0.2)"
                        : "transparent"
                    }
                  }
                }}
              >
                {rightLines.map((line) => line.value).join("\n")}
              </SyntaxHighlighter>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

interface DebugProps {
  isProcessing: boolean
  setIsProcessing: (isProcessing: boolean) => void
}

const Debug: React.FC<DebugProps> = ({ isProcessing, setIsProcessing }) => {
  const queryClient = useQueryClient()
  const contentRef = useRef<HTMLDivElement>(null)

  const [oldCode, setOldCode] = useState<string | null>(null)
  const [newCode, setNewCode] = useState<string | null>(null)
  const [thoughtsData, setThoughtsData] = useState<string[] | null>(null)
  const [timeComplexityData, setTimeComplexityData] = useState<string | null>(
    null
  )
  const [spaceComplexityData, setSpaceComplexityData] = useState<string | null>(
    null
  )

  const [toastOpen, setToastOpen] = useState(false)
  const [toastMessage, setToastMessage] = useState<ToastMessage>({
    title: "",
    description: "",
    variant: "neutral"
  })

  const [isTooltipVisible, setIsTooltipVisible] = useState(false)
  const [tooltipHeight, setTooltipHeight] = useState(0)

  const { data: extraScreenshots = [], refetch } = useQuery({
    queryKey: ["extras"],
    queryFn: async () => {
      try {
        const existing = await window.electronAPI.getScreenshots()
        return existing
      } catch (error) {
        console.error("Error loading extra screenshots:", error)
        return []
      }
    },
    staleTime: Infinity,
    cacheTime: Infinity
  })

  const showToast = (
    title: string,
    description: string,
    variant: ToastVariant
  ) => {
    setToastMessage({ title, description, variant })
    setToastOpen(true)
  }

  const handleDeleteExtraScreenshot = async (index: number) => {
    const screenshotToDelete = extraScreenshots[index]

    try {
      const response = await window.electronAPI.deleteScreenshot(
        screenshotToDelete.path
      )

      if (response.success) {
        refetch()
      } else {
        console.error("Failed to delete extra screenshot:", response.error)
      }
    } catch (error) {
      console.error("Error deleting extra screenshot:", error)
    }
  }

  useEffect(() => {
    // Try to get the new solution data from cache first
    const newSolution = queryClient.getQueryData(["new_solution"]) as {
      old_code: string
      new_code: string
      thoughts: string[]
      time_complexity: string
      space_complexity: string
    } | null

    // If we have cached data, set all state variables to the cached data
    if (newSolution) {
      setOldCode(newSolution.old_code || null)
      setNewCode(newSolution.new_code || null)
      setThoughtsData(newSolution.thoughts || null)
      setTimeComplexityData(newSolution.time_complexity || null)
      setSpaceComplexityData(newSolution.space_complexity || null)
      setIsProcessing(false)
    }

    // Set up event listeners
    const cleanupFunctions = [
      window.electronAPI.onScreenshotTaken(() => refetch()),
      window.electronAPI.onResetView(() => refetch()),
      window.electronAPI.onDebugSuccess(() => {
        setIsProcessing(false) //all the other stuff ahapepns in the parent component, so we just need to do this.
      }),
      window.electronAPI.onDebugStart(() => {
        setIsProcessing(true)
      }),
      window.electronAPI.onDebugError((error: string) => {
        showToast(
          "Processing Failed",
          "There was an error debugging your code.",
          "error"
        )
        setIsProcessing(false)
        console.error("Processing error:", error)
      })
    ]

    // Set up resize observer
    const updateDimensions = () => {
      if (contentRef.current) {
        let contentHeight = contentRef.current.scrollHeight
        const contentWidth = contentRef.current.scrollWidth
        if (isTooltipVisible) {
          contentHeight += tooltipHeight
        }
        window.electronAPI.updateContentDimensions({
          width: contentWidth,
          height: contentHeight
        })
      }
    }

    const resizeObserver = new ResizeObserver(updateDimensions)
    if (contentRef.current) {
      resizeObserver.observe(contentRef.current)
    }
    updateDimensions()

    return () => {
      resizeObserver.disconnect()
      cleanupFunctions.forEach((cleanup) => cleanup())
    }
  }, [queryClient])

  const handleTooltipVisibilityChange = (visible: boolean, height: number) => {
    setIsTooltipVisible(visible)
    setTooltipHeight(height)
  }

  return (
    <div ref={contentRef} className="relative space-y-3 px-4 py-3 ">
      <Toast
        open={toastOpen}
        onOpenChange={setToastOpen}
        variant={toastMessage.variant}
        duration={3000}
      >
        <ToastTitle>{toastMessage.title}</ToastTitle>
        <ToastDescription>{toastMessage.description}</ToastDescription>
      </Toast>

      {/* Conditionally render the screenshot queue */}
      <div className="bg-transparent w-fit">
        <div className="pb-3">
          <div className="space-y-3 w-fit">
            <ScreenshotQueue
              screenshots={extraScreenshots}
              onDeleteScreenshot={handleDeleteExtraScreenshot}
              isLoading={isProcessing}
            />
          </div>
        </div>
      </div>

      {/* Navbar of commands with the tooltip */}
      <ExtraScreenshotsQueueHelper
        extraScreenshots={extraScreenshots}
        onTooltipVisibilityChange={handleTooltipVisibilityChange}
      />

      {/* Main Content */}
      <div className="w-full card-floating text-sm">
        <div className="rounded-lg overflow-hidden">
          <div className="px-4 py-3 space-y-4">
            {/* Thoughts Section */}
            <ContentSection
              title="What I Changed"
              content={
                thoughtsData && (
                  <div className="space-y-3">
                    <div className="space-y-1">
                      {thoughtsData.map((thought, index) => (
                        <div key={index} className="flex items-start gap-2">
                          <div className="w-1 h-1 rounded-full bg-blue-400/80 mt-2 shrink-0" />
                          <div>{thought}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )
              }
              isLoading={!thoughtsData}
            />

            {/* Code Comparison Section */}
            <CodeComparisonSection
              oldCode={oldCode}
              newCode={newCode}
              isLoading={!oldCode || !newCode}
            />

            {/* Complexity Section */}
            <ComplexitySection
              timeComplexity={timeComplexityData}
              spaceComplexity={spaceComplexityData}
              isLoading={!timeComplexityData || !spaceComplexityData}
            />
          </div>
        </div>
      </div>
    </div>
  )
}

export default Debug

===== END FILE: src\_pages\Debug.tsx =====

===== BEGIN FILE: src\_pages\Queue.tsx =====
import React, { useState, useEffect, useRef } from "react"
import { flushSync } from "react-dom"
import { useQuery } from "react-query"
import { 
  RiCloseLine as X, 
  RiSendPlaneLine as Send, 
  RiMessage3Line as MessageCircle,
  RiSparklingLine as Sparkles,
  RiCameraLine as Camera,
  RiMicLine as Mic,
  RiSettings3Line as Settings,
  RiRobotLine as Robot,
  RiImageLine as Image,
  RiVoiceprintLine as Voice
} from "react-icons/ri"
import ScreenshotQueue from "../components/Queue/ScreenshotQueue"
import {
  Toast,
  ToastTitle,
  ToastDescription,
  ToastVariant,
  ToastMessage,
  ToastClose
} from "../components/ui/toast"
import QueueCommands from "../components/Queue/QueueCommands"
import ModelSelector from "../components/ui/ModelSelector"
import { Button } from "../components/ui/button"
import { Input } from "../components/ui/input"
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "../components/ui/card"
import Badge from '../components/ui/badge'
import { Separator } from "../components/ui/separator"
import MarkdownRenderer from "../components/ui/MarkdownRenderer"
import LiveTranscriptPanel from "../components/Transcription/LiveTranscriptPanel"
import StealthControls from "../components/ui/StealthControls"

interface QueueProps {
  setView: React.Dispatch<React.SetStateAction<"queue" | "solutions" | "debug">>
}

const Queue: React.FC<QueueProps> = ({ setView }) => {
  const [toastOpen, setToastOpen] = useState(false)
  const [toastMessage, setToastMessage] = useState<ToastMessage>({
    title: "",
    description: "",
    variant: "neutral"
  })

  const [isTooltipVisible, setIsTooltipVisible] = useState(false)
  const [tooltipHeight, setTooltipHeight] = useState(0)
  const contentRef = useRef<HTMLDivElement>(null)
  const lastSizeRef = useRef<{ w: number; h: number }>({ w: 0, h: 0 })
  const resizeTimerRef = useRef<number | null>(null)
  const didCenterRef = useRef<boolean>(false)
  // Let measured toolbar width decide final window size (no forced full width)
  const [toolbarWidth, setToolbarWidth] = useState(0)

  const [chatInput, setChatInput] = useState("")
  const [chatMessages, setChatMessages] = useState<{role: "user"|"gemini", text: string}[]>([])
  const [showSettings, setShowSettings] = useState(false)
  const [showChat, setShowChat] = useState(false)
  const [showTranscript, setShowTranscript] = useState(false)
  const [showStealthControls, setShowStealthControls] = useState(false)
  const [isChatOpen, setIsChatOpen] = useState(false)
  const [chatLoading, setChatLoading] = useState(false)
  const chatInputRef = useRef<HTMLInputElement>(null)
  
  const [isSettingsOpen, setIsSettingsOpen] = useState(false)
  const [isTranscriptOpen, setIsTranscriptOpen] = useState(false)
  const [currentModel, setCurrentModel] = useState<{ provider: string; model: string }>({ provider: "gemini", model: "gemini-2.5-flash-lite-preview-09-2025" })
  const [isRecording, setIsRecording] = useState(false)
  const mediaRecorderRef = useRef<MediaRecorder | null>(null)
  const audioChunksRef = useRef<Blob[]>([])
  const mediaStreamRef = useRef<MediaStream | null>(null)
  const [showSolutionPanel, setShowSolutionPanel] = useState(false)
  const [solutionStatus, setSolutionStatus] = useState<string>("")
  const [solveText, setSolveText] = useState<string | null>(null)
  // Toolbar indicators
  const [stealthEnabled, setStealthEnabled] = useState<boolean>(true)
  const [windowVisible, setWindowVisible] = useState<boolean>(true)

  // License / Trial state
  const [licenseStatus, setLicenseStatus] = useState<{ deviceId: string; status: "active"|"expired"|"banned"|"unknown"; trialEndISO: string|null; serverTimeISO: string|null; daysLeft: number; offline: boolean; message?: string } | null>(null)

  // Attach this to the content wrapper so the Electron window resizes to fit
  // toolbar + any expanded panels (chat/settings)
  const barRef = useRef<HTMLDivElement>(null)

  const { data: screenshots = [], refetch } = useQuery<Array<{ path: string; preview: string }>, Error>(
    ["screenshots"],
    async () => {
      try {
        const existing = await window.electronAPI.getScreenshots()
        return existing
      } catch (error) {
        console.error("Error loading screenshots:", error)
        showToast("Error", "Failed to load existing screenshots", "error")
        return []
      }
    },
    {
      staleTime: Infinity,
      cacheTime: Infinity,
      refetchOnWindowFocus: true,
      refetchOnMount: true
    }
  )

  const showToast = (
    title: string,
    description: string,
    variant: ToastVariant
  ) => {
    setToastMessage({ title, description, variant })
    setToastOpen(true)
  }

  const handleDeleteScreenshot = async (index: number) => {
    const screenshotToDelete = screenshots[index]

    try {
      const response = await window.electronAPI.deleteScreenshot(
        screenshotToDelete.path
      )

      if (response.success) {
        refetch()
      } else {
        console.error("Failed to delete screenshot:", response.error)
        showToast("Error", "Failed to delete the screenshot file", "error")
      }
    } catch (error) {
      console.error("Error deleting screenshot:", error)
    }
  }

  const handleChatSend = async () => {
    if (!chatInput.trim()) return
    setChatMessages((msgs) => [...msgs, { role: "user", text: chatInput }])
    setChatLoading(true)
    setChatInput("")
    try {
      const response = await window.electronAPI.invoke("gemini-chat", chatInput)
      setChatMessages((msgs) => [...msgs, { role: "gemini", text: response }])
    } catch (err) {
      setChatMessages((msgs) => [...msgs, { role: "gemini", text: "Error: " + String(err) }])
    } finally {
      setChatLoading(false)
      chatInputRef.current?.focus()
    }
  }

  // Load current model configuration on mount
  useEffect(() => {
    const loadCurrentModel = async () => {
      try {
        const config = await window.electronAPI.getCurrentLlmConfig();
        setCurrentModel({ provider: config.provider, model: config.model });
      } catch (error) {
        console.error('Error loading current model config:', error);
      }
    };
    loadCurrentModel();
  }, []);

  // Emergency hide animation hook
  useEffect(() => {
    const unsubscribe = window.electronAPI.onEmergencyHide(() => {
      const body = document.body;
      const app = document.getElementById('root') || document.getElementById('app');
      body.classList.add('emergency-hide');
      app?.classList.add('emergency-hide');
      // Clean up after animation completes
      setTimeout(() => {
        body.classList.remove('emergency-hide');
        app?.classList.remove('emergency-hide');
      }, 320);
    });
    return () => { unsubscribe && unsubscribe(); }
  }, []);

  useEffect(() => {
    const updateNow = () => {
      if (!contentRef.current) return
      // Round to avoid sub-pixel oscillations
      let h = Math.ceil(contentRef.current.offsetHeight)
      const contentW = Math.ceil(contentRef.current.offsetWidth)
      const w = toolbarWidth > 0 ? toolbarWidth : contentW
      if (isTooltipVisible) h += Math.ceil(tooltipHeight)
      const { w: lw, h: lh } = lastSizeRef.current
      if (w === lw && h === lh) return
      lastSizeRef.current = { w, h }
      window.electronAPI.updateContentDimensions({ width: w, height: h })
      // After the first sizing, center and show the window to guarantee the full toolbar is visible
      if (!didCenterRef.current) {
        didCenterRef.current = true
        window.electronAPI.invoke("center-and-show-window").catch(() => {})
      }
    }

    const updateDimensions = () => {
      if (resizeTimerRef.current) window.clearTimeout(resizeTimerRef.current)
      resizeTimerRef.current = window.setTimeout(updateNow, 50)
    }

    const resizeObserver = new ResizeObserver(updateDimensions)
    if (contentRef.current) {
      resizeObserver.observe(contentRef.current)
    }
    updateDimensions()

    const cleanupFunctions = [
      window.electronAPI.onScreenshotTaken(() => refetch()),
      window.electronAPI.onResetView(() => refetch()),
      window.electronAPI.onSolutionStart(() => {
        // Close other panels and show only Solve
        setIsChatOpen(false)
        setIsSettingsOpen(false)
        setShowSolutionPanel(true)
        setSolutionStatus("Processing...")
        setSolveText(null)
      }),
      window.electronAPI.onProblemExtracted((data: any) => {
        setIsChatOpen(false)
        setIsSettingsOpen(false)
        setShowSolutionPanel(true)
        setSolutionStatus("Analysis ready")
        // Show the extracted text in the solve panel and optionally in chat
        const text = typeof data === 'string' ? data : (data?.problem_statement || JSON.stringify(data))
        setSolveText(String(text))
        if (text) {
          setChatMessages((msgs) => [...msgs, { role: "gemini", text: String(text) }])
        }
      }),
      window.electronAPI.onSolutionSuccess((data: any) => {
        setIsChatOpen(false)
        setIsSettingsOpen(false)
        setShowSolutionPanel(true)
        setSolutionStatus("Solution ready")
        const text = data?.solution?.code || data?.text || JSON.stringify(data)
        if (text) setSolveText(String(text))
      }),
      window.electronAPI.onSolutionError((error: string) => {
        showToast(
          "Processing Failed",
          "There was an error processing your screenshots.",
          "error"
        )
        setView("queue")
        console.error("Processing error:", error)
        setShowSolutionPanel(true)
        setSolutionStatus("Error while processing")
      }),
      window.electronAPI.onProcessingNoScreenshots(() => {
        showToast(
          "No Screenshots",
          "There are no screenshots to process.",
          "neutral"
        )
      })
    ]

    return () => {
      resizeObserver.disconnect()
      if (resizeTimerRef.current) {
        window.clearTimeout(resizeTimerRef.current)
        resizeTimerRef.current = null
      }
      cleanupFunctions.forEach((cleanup) => cleanup())
    }
  }, [isTooltipVisible, tooltipHeight, toolbarWidth])

  // Seamless screenshot-to-LLM flow
  useEffect(() => {
    // Listen for screenshot taken event
    const unsubscribe = window.electronAPI.onScreenshotTaken(async (data) => {
      // Refetch screenshots to update the queue
      await refetch();
      // Show loading in chat
      setChatLoading(true);
      try {
        // Get the latest screenshot path
        const latest = data?.path || (Array.isArray(data) && data.length > 0 && data[data.length - 1]?.path);
        if (latest) {
          // Call the LLM to process the screenshot
          const response = await window.electronAPI.invoke("analyze-image-file", latest);
          setChatMessages((msgs) => [...msgs, { role: "gemini", text: response.text }]);
        }
      } catch (err) {
        setChatMessages((msgs) => [...msgs, { role: "gemini", text: "Error: " + String(err) }]);
      } finally {
        setChatLoading(false);
      }
    });
    return () => {
      unsubscribe && unsubscribe();
    };
  }, [refetch]);

  // Load license status on mount and every 6 hours
  useEffect(() => {
    let mounted = true
    const load = async () => {
      try {
        const s = await window.electronAPI.getLicenseStatus()
        if (mounted) setLicenseStatus(s)
      } catch {}
    }
    load()
    const id = setInterval(load, 6 * 60 * 60 * 1000)
    return () => { mounted = false; clearInterval(id) }
  }, [])

  // Subscribe to visibility and content-protection changes for toolbar badges
  useEffect(() => {
    const un1 = window.electronAPI.onContentProtectionChanged((enabled) => setStealthEnabled(!!enabled))
    const un2 = window.electronAPI.onWindowVisibilityChanged((visible) => setWindowVisible(!!visible))
    return () => { try { un1 && un1() } catch {}; try { un2 && un2() } catch {} }
  }, [])

  // Respond to global Stealth Cycle shortcut: Normal ‚Üí Stealth ‚Üí Ultra ‚Üí Normal
  useEffect(() => {
    const unsubscribe = window.electronAPI.onStealthCycle(() => {
      const body = document.body;
      const app = document.getElementById('root') || document.getElementById('app');

      const hasUltra = body.classList.contains('stealth-ultra') || app?.classList.contains('stealth-ultra');
      const hasStealth = body.classList.contains('stealth-mode') || app?.classList.contains('stealth-mode');

      if (hasUltra) {
        // Ultra ‚Üí Normal
        body.classList.remove('stealth-ultra', 'stealth-mode');
        app?.classList.remove('stealth-ultra', 'stealth-mode');
        // Preserve user's chosen transparency; if saved, re-apply it, otherwise keep current
        try {
          const saved = localStorage.getItem('stealth.opacity');
          if (saved != null) {
            const parsed = parseInt(saved, 10);
            if (!Number.isNaN(parsed) && parsed >= 5 && parsed <= 100) {
              document.documentElement.style.setProperty('--stealth-opacity', String(parsed / 100));
            }
          }
        } catch {}
      } else if (hasStealth) {
        // Stealth ‚Üí Ultra
        body.classList.remove('stealth-mode');
        app?.classList.remove('stealth-mode');
        body.classList.add('stealth-ultra');
        app?.classList.add('stealth-ultra');
      } else {
        // Normal ‚Üí Stealth
        body.classList.add('stealth-mode');
        app?.classList.add('stealth-mode');
      }
    });
    return () => { unsubscribe && unsubscribe(); }
  }, []);

  const handleTooltipVisibilityChange = (visible: boolean, height: number) => {
    setIsTooltipVisible(visible)
    setTooltipHeight(height)
  }

  // Helper function to close all panels
  const closeAllPanels = () => {
    setIsChatOpen(false)
    setIsSettingsOpen(false)
    setIsTranscriptOpen(false)
    setShowSolutionPanel(false)
  }

  const handleChatToggle = () => {
    const wasOpen = isChatOpen
    closeAllPanels()
    // Only open if it wasn't already open
    if (!wasOpen) {
      setIsChatOpen(true)
    }
  }

  const handleSettingsToggle = () => {
    const wasOpen = isSettingsOpen
    closeAllPanels()
    // Only open if it wasn't already open
    if (!wasOpen) {
      setIsSettingsOpen(true)
    }
  }

  const handleTranscriptToggle = () => {
    const wasOpen = isTranscriptOpen
    closeAllPanels()
    // Only open if it wasn't already open
    if (!wasOpen) {
      setIsTranscriptOpen(true)
    }
  }

  const handleToggleRecording = async () => {
    try {
      if (!isRecording) {
        // Start recording
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
        mediaStreamRef.current = stream
        const recorder = new MediaRecorder(stream)
        mediaRecorderRef.current = recorder
        audioChunksRef.current = []

        recorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) audioChunksRef.current.push(e.data)
        }
        recorder.onstop = async () => {
          try {
            const blobType = audioChunksRef.current[0]?.type || 'audio/webm'
            const blob = new Blob(audioChunksRef.current, { type: blobType })
            // Release mic
            mediaStreamRef.current?.getTracks().forEach(t => t.stop())
            mediaStreamRef.current = null

            // Convert to base64 and send to Electron for analysis
            const arrayBuffer = await blob.arrayBuffer()
            const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)))
            // Close other panels and open chat
            setIsSettingsOpen(false)
            setShowSolutionPanel(false)
            setIsChatOpen(true)
            
            // Add processing message to chat
            setChatMessages((msgs) => [...msgs, { role: 'user', text: 'üé§ Audio recording processed' }])
            setChatLoading(true)
            
            const result = await window.electronAPI.analyzeAudioFromBase64(base64, blob.type)

            // Add AI response to chat
            setChatLoading(false)
            setChatMessages((msgs) => [...msgs, { role: 'gemini', text: result.text }])
          } catch (err) {
            console.error('Audio processing failed:', err)
            showToast('Error', 'Failed to analyze audio', 'error')
            setChatLoading(false)
            setChatMessages((msgs) => [...msgs, { role: 'gemini', text: 'Sorry, I encountered an error while processing your audio recording. Please try again.' }])
          } finally {
            mediaRecorderRef.current = null
            audioChunksRef.current = []
          }
        }

        recorder.start()
        setIsRecording(true)
      } else {
        // Stop recording
        mediaRecorderRef.current?.stop()
        setIsRecording(false)
      }
    } catch (err) {
      console.error('Recording error:', err)
      showToast('Error', 'Microphone permission denied or unavailable', 'error')
    }
  }

  // Combined flow: capture a screenshot and immediately send to solution
  const handleCaptureAndSolve = async () => {
    try {
      if (licenseStatus && (licenseStatus.status === "expired" || licenseStatus.status === "banned")) {
        showToast("Trial Ended", "Your free trial has ended. Please activate to continue.", "error")
        return
      }
      const result = await window.electronAPI.takeScreenshot()
      if (result?.path) {
        showToast("Screenshot", "Captured successfully", "success")
        await refetch()
        
        // Close other panels first, then open chat with a slight delay
        setIsSettingsOpen(false)
        setShowSolutionPanel(false)
        
        // Use setTimeout to ensure state updates are applied before opening chat
        setTimeout(async () => {
          setIsChatOpen(true)
          
          // Add processing message to chat
          setChatMessages((msgs) => [...msgs, { role: 'user', text: 'üì∏ Screenshot captured and analyzing...' }])
          setChatLoading(true)
          
          await window.electronAPI.invoke("process-screenshots")
        }, 50)
      } else {
        showToast("Screenshot", "No screenshot captured", "neutral")
      }
    } catch (error) {
      console.error(error)
      showToast("Error", "Failed to capture or analyze", "error")
      setChatLoading(false)
      setChatMessages((msgs) => [...msgs, { role: 'gemini', text: 'Sorry, I encountered an error while analyzing the screenshot. Please try again.' }])
    }
  }

  const handleGetSolution = () => {
    showToast("Solution", "Getting solution...", "neutral")
    
    // Force close other panels and immediately open chat - no delays
    setIsSettingsOpen(false)
    setShowSolutionPanel(false)
    setIsChatOpen(true)
    
    // Force chat to be visible by using flushSync to ensure immediate state update
    flushSync(() => {
      setIsChatOpen(true)
    })
    
    // Add processing message to chat
    setChatMessages((msgs) => [...msgs, { role: 'user', text: 'üîç Analyzing screenshots for solution...' }])
    setChatLoading(true)
    
    window.electronAPI.invoke("process-screenshots").catch((err) => {
      console.error("process-screenshots error", err)
      showToast("Error", "Failed to start processing", "error")
      setChatLoading(false)
      setChatMessages((msgs) => [...msgs, { role: 'gemini', text: 'Sorry, I encountered an error while processing. Please try again.' }])
    })
  }

  const handleModelChange = (provider: "ollama" | "gemini", model: string) => {
    setCurrentModel({ provider, model })
    // Update chat messages to reflect the model change
    const modelName = provider === "ollama" ? model : "MindWhisper AI"
    setChatMessages((msgs) => [...msgs, { 
      role: "gemini", 
      text: `üîÑ Switched to ${provider === "ollama" ? "üè†" : "‚òÅÔ∏è"} ${modelName}. Ready for your questions!` 
    }])
  }


  return (
    <div
      ref={contentRef}
      style={{ position: "relative", pointerEvents: "auto" }}
      className="select-none inline-block w-full max-w-[580px] animate-cmd-enter"
    >
      <div className="bg-transparent w-full">
        <div className="relative px-4 pt-6 pb-3 w-full">
          <div className="absolute top-0 right-3">
            <Toast
              open={toastOpen}
              onOpenChange={setToastOpen}
              variant={toastMessage.variant}
              duration={3000}
            >
              <ToastClose className="text-xs text-white/80 transition hover:text-white" />
              <ToastTitle>{toastMessage.title}</ToastTitle>
              <ToastDescription>{toastMessage.description}</ToastDescription>
            </Toast>
          </div>
          <div className="flex flex-col gap-4">
          {/* Premium Trial/License Banner */}
          {licenseStatus && (
            <Card className="card-floating w-full animate-cmd-enter hover-lift">
              <CardContent className="py-3 px-4 flex flex-col gap-3">
                <div className="flex items-center justify-between gap-4 flex-wrap">
                  <div className="flex items-center gap-3">
                    <Badge variant={licenseStatus.status === 'active' ? 'success' : licenseStatus.status === 'expired' ? 'warning' : 'destructive'} size="default" className="font-semibold">
                      {licenseStatus.status === 'active' ? 'Trial Active' : licenseStatus.status === 'expired' ? 'Trial Expired' : licenseStatus.status === 'banned' ? 'Banned' : 'Unknown'}
                    </Badge>
                    <span className="text-sm text-stealth-text-secondary font-medium">
                      {licenseStatus.status === 'active' ? `${licenseStatus.daysLeft} day${licenseStatus.daysLeft===1?'':'s'} left` : 'Activation required'}
                    </span>
                    {licenseStatus.offline && (
                      <Badge variant="warning" size="sm" className="text-[10px]">Offline</Badge>
                    )}
                  </div>
                  <div className="flex items-center gap-3">
                    <Button size="sm" variant="outline" className="h-8 px-4 text-xs font-medium hover-lift spring-bounce" onClick={async()=>{
                      try {
                        const s = await window.electronAPI.forceVerifyLicense()
                        setLicenseStatus(s)
                        if (s.status === 'active') {
                          showToast('License', 'Verified successfully', 'success')
                        } else {
                          showToast('License', 'Trial ended or invalid', 'error')
                        }
                      } catch {}
                    }}>Refresh</Button>
                    {licenseStatus.status !== 'active' && (
                      <Button size="sm" className="h-8 px-4 text-xs font-semibold hover-lift spring-bounce" onClick={()=> showToast('Activation', 'Please visit our website to activate.', 'neutral')}>Activate</Button>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>
          )}
        </div>
        <div className="w-fit mx-auto">
            <QueueCommands
              isRecording={isRecording}
              onToggleRecording={handleToggleRecording}
              onCaptureAndSolve={handleCaptureAndSolve}
              screenshots={screenshots.map(s => s.path)}
              isVisible={true}
              onClose={() => window.electronAPI.toggleApp()}
              onChatToggle={() => setIsChatOpen(!isChatOpen)}
              onSettingsToggle={() => setIsSettingsOpen(!isSettingsOpen)}
              onTranscriptToggle={() => setIsTranscriptOpen(!isTranscriptOpen)}
              onStealthToggle={() => setShowStealthControls(!showStealthControls)}
              onMeasureWidth={(w) => setToolbarWidth((prev) => Math.max(prev, w))}
              positionFixed={false}
              stealthEnabled={stealthEnabled}
            />
          </div>
          {/* Dynamic Panel Container - Only one panel visible at a time */}
          {(isSettingsOpen || isChatOpen || isTranscriptOpen || showSolutionPanel || showStealthControls) && (
            <div
              className="mt-8 mx-auto"
              style={{ width: toolbarWidth > 0 ? `${toolbarWidth}px` : undefined }}
            >
              {/* Compact Settings Interface */}
              {isSettingsOpen && (
                <Card className="card-floating w-full animate-cmd-enter">
                  <CardHeader className="pb-3">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center space-x-2">
                        <div className="w-6 h-6 rounded-md bg-primary flex items-center justify-center">
                          {/* Keyboard icon */}
                          <svg className="w-3 h-3 text-primary-foreground" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <rect x="3" y="7" width="18" height="10" rx="2" ry="2" strokeWidth="2"/>
                            <path strokeWidth="2" d="M6 10h2M10 10h2M14 10h2M18 10h0M6 13h3M10.5 13h3M15 13h3" strokeLinecap="round"/>
                          </svg>
                        </div>
                        <div>
                          <CardTitle className="text-sm font-semibold text-foreground flex items-center gap-1">
                            Shortcuts
                            <Sparkles className="w-3 h-3 text-foreground" />
                          </CardTitle>
                          <CardDescription className="text-xs text-muted-foreground">Quick commands to control the app</CardDescription>
                        </div>
                      </div>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => setIsSettingsOpen(false)}
                        className="hover-scale press-down h-6 w-6 p-0"
                      >
                        <X className="w-3 h-3" />
                      </Button>
                    </div>
                  </CardHeader>
                  <CardContent className="pt-0 pb-4">
                    <div className="grid grid-cols-1 gap-2">
                      <div className="flex items-center justify-between bg-stealth-card border border-stealth rounded-lg px-3 py-2">
                        <span className="text-xs text-foreground">Toggle App Visibility</span>
                        <span className="text-[11px] font-mono bg-white/10 px-2 py-0.5 rounded">Ctrl + B</span>
                      </div>
                      <div className="flex items-center justify-between bg-stealth-card border border-stealth rounded-lg px-3 py-2">
                        <span className="text-xs text-foreground">Capture Screenshot</span>
                        <span className="text-[11px] font-mono bg-white/10 px-2 py-0.5 rounded">Ctrl + H</span>
                      </div>
                      <div className="flex items-center justify-between bg-stealth-card border border-stealth rounded-lg px-3 py-2">
                        <span className="text-xs text-foreground">Get Solution</span>
                        <span className="text-[11px] font-mono bg-white/10 px-2 py-0.5 rounded">Ctrl + Enter</span>
                      </div>
                      <div className="flex items-center justify-between bg-stealth-card border border-stealth rounded-lg px-3 py-2">
                        <span className="text-xs text-foreground">Stealth Cycle (Normal ‚Üí Stealth ‚Üí Ultra)</span>
                        <span className="text-[11px] font-mono bg-white/10 px-2 py-0.5 rounded">Ctrl + Shift + S</span>
                      </div>
                      <div className="flex items-center justify-between bg-stealth-card border border-stealth rounded-lg px-3 py-2">
                        <span className="text-xs text-foreground">Open Chat</span>
                        <span className="text-[11px] font-mono bg-white/10 px-2 py-0.5 rounded">Click Chat</span>
                      </div>
                      <div className="flex items-center justify-between bg-stealth-card border border-stealth rounded-lg px-3 py-2">
                        <span className="text-xs text-foreground">Live Mode Transcription</span>
                        <span className="text-[11px] font-mono bg-white/10 px-2 py-0.5 rounded">Click Live Mode</span>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              )}

              {/* Premium Chat Interface */}
              {isChatOpen && (
                <Card className="card-floating w-full animate-cmd-enter">
                  <CardHeader className="pb-4">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center space-x-4">
                        <div className="w-8 h-8 rounded-lg bg-primary flex items-center justify-center shadow-sm">
                          <MessageCircle className="w-4 h-4 text-primary-foreground" />
                        </div>
                        <div>
                          <CardTitle className="text-base font-semibold text-foreground flex items-center gap-2">
                            AI Assistant
                            <Robot className="w-3 h-3 text-foreground" />
                          </CardTitle>
                          <CardDescription className="text-xs text-muted-foreground font-normal flex items-center gap-2">
                            {currentModel.provider === "ollama" ? (
                              <><span className="w-2 h-2 rounded-full bg-foreground"></span> Local: {currentModel.model}</>
                            ) : (
                              <><span className="w-2 h-2 rounded-full bg-foreground"></span> Cloud: MindWhisper AI</>
                            )}
                          </CardDescription>
                        </div>
                      </div>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => setIsChatOpen(false)}
                        className="hover-scale press-down"
                      >
                        <X className="w-4 h-4" />
                      </Button>
                    </div>
                  </CardHeader>
                  <CardContent className="space-y-6">
                    <div className="flex-1 overflow-y-auto space-y-3 min-h-[200px] max-h-[350px] bg-stealth-card rounded-lg p-3 border border-stealth backdrop-blur-md">
                      {chatMessages.map((message, index) => (
                        <div
                          key={index}
                          className={`flex ${message.role === "user" ? "justify-end" : "justify-start"}`}
                        >
                          <div className={`max-w-[80%] rounded-xl px-3 py-2 shadow-sm transition-all duration-200 animate-cmd-enter ${
                            message.role === "user" 
                              ? "bg-primary text-primary-foreground ml-4 hover:shadow-md" 
                              : "card-premium text-foreground mr-4"
                          }`}>
                            {message.role === "user" ? (
                              <p className="whitespace-pre-wrap text-sm leading-relaxed font-medium">{message.text}</p>
                            ) : (
                              <MarkdownRenderer content={message.text} className="text-sm" />
                            )}
                          </div>
                        </div>
                      ))}
                      {chatLoading && (
                        <div className="flex justify-start">
                          <div className="max-w-[80%] rounded-xl px-3 py-2 card-premium mr-4 animate-cmd-enter">
                            <div className="flex items-center gap-2">
                              <div className="loading">
                                <div className="loading-dot"></div>
                                <div className="loading-dot"></div>
                                <div className="loading-dot"></div>
                              </div>
                              <span className="text-xs font-medium text-muted-foreground">AI is thinking...</span>
                            </div>
                          </div>
                        </div>
                      )}
                    </div>

                    <div className="flex gap-2 items-end">
                      <div className="flex-1">
                        <Input
                          type="text"
                          value={chatInput}
                          onChange={(e: any) => setChatInput(e.target.value)}
                          onKeyPress={(e: any) => e.key === "Enter" && !e.shiftKey && handleChatSend()}
                          placeholder="Ask me anything..."
                          disabled={chatLoading}
                          className=""
                        />
                      </div>
                      <Button
                        onClick={handleChatSend}
                        disabled={chatLoading || !chatInput.trim()}
                        className="hover-lift spring-bounce"
                      >
                        <Send className="w-4 h-4" />
                      </Button>
                    </div>
                  </CardContent>
                </Card>
              )}

              {/* Premium Live Transcription Interface */}
              {isTranscriptOpen && (
                <div className="w-full">
                  <LiveTranscriptPanel />
                </div>
              )}

              {/* Compact Stealth Controls Panel */}
              {showStealthControls && (
                <div className="w-full">
                  <Card className="card-floating w-full animate-cmd-enter">
                    <CardHeader className="pb-3">
                      <div className="flex items-center justify-between">
                        <div>
                          <CardTitle className="text-sm font-semibold text-foreground flex items-center gap-2">
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L12 12m6.121-6.121A2.98 2.98 0 0119 8c0 .597-.176 1.152-.487 1.618m-7.681 8.207l6.294-6.294" />
                            </svg>
                            Stealth Controls
                          </CardTitle>
                        </div>
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => setShowStealthControls(false)}
                          className="hover-scale press-down h-6 w-6 p-0"
                        >
                          <X className="w-3 h-3" />
                        </Button>
                      </div>
                    </CardHeader>
                    <CardContent className="pt-0 pb-4">
                      <StealthControls />
                    </CardContent>
                  </Card>
                </div>
              )}

            </div>
          )}


          {/* Premium Recording Status */}
          {isRecording && (
            <div className="mt-8 w-full mx-auto">
              <Card className="card-floating">
                <CardContent className="p-8 pt-6 pb-8 flex items-center gap-4">
                  <div className="relative">
                    <div className="w-3 h-3 rounded-full bg-primary recording-pulse" />
                    <div className="absolute inset-0 w-3 h-3 rounded-full bg-primary animate-ping opacity-75" />
                  </div>
                  <div className="flex-1 space-y-3">
                    <div className="flex items-center gap-2">
                      <Voice className="w-4 h-4 text-foreground" />
                      <span className="text-sm font-semibold text-foreground">Recording Audio</span>
                    </div>
                    <p className="text-xs text-muted-foreground font-normal">
                      Speak clearly for best AI analysis results
                    </p>
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={handleToggleRecording}
                    className="hover-scale press-down"
                  >
                    Stop Recording
                  </Button>
                </CardContent>
              </Card>
            </div>
          )}

        </div>
      </div>
    </div>
  )
}
export default Queue

===== END FILE: src\_pages\Queue.tsx =====

===== BEGIN FILE: src\_pages\Solutions.tsx =====
// Solutions.tsx
import React, { useState, useEffect, useRef } from "react"
import { useQuery, useQueryClient } from "react-query"
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter"
import { dracula } from "react-syntax-highlighter/dist/esm/styles/prism"

import ScreenshotQueue from "../components/Queue/ScreenshotQueue"
import {
  Toast,
  ToastDescription,
  ToastMessage,
  ToastTitle,
  ToastVariant
} from "../components/ui/toast"
import { ProblemStatementData } from "../types/solutions"
import { AudioResult } from "../types/audio"
import QueueCommands from "../components/Queue/QueueCommands"
import Debug from "./Debug"
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "../components/ui/card"
import MarkdownRenderer from "../components/ui/MarkdownRenderer"

// (Using global ElectronAPI type from src/types/electron.d.ts)

export const ContentSection = ({
  title,
  content,
  isLoading
}: {
  title: string
  content: React.ReactNode
  isLoading: boolean
}) => (
  <Card className="card-premium group hover:shadow-stealth-lg transition-all duration-300">
    <CardHeader className="pb-4">
      <CardTitle className="text-sm font-semibold text-foreground tracking-wide flex items-center gap-2 group-hover:text-primary transition-colors duration-200">
        <div className="w-1.5 h-1.5 bg-primary rounded-full opacity-60 group-hover:opacity-100 transition-opacity duration-200"></div>
        {title}
      </CardTitle>
    </CardHeader>
    <CardContent className="pt-0">
      {isLoading ? (
        <div className="flex items-center gap-3 p-4 bg-stealth-card/20 rounded-lg border border-stealth-border/30">
          <div className="w-4 h-4 border-2 border-primary/30 border-t-primary rounded-full animate-spin"></div>
          <p className="text-sm text-muted-foreground">
            Extracting problem statement...
          </p>
        </div>
      ) : (
        <div className="text-sm leading-relaxed text-foreground/90 max-w-[600px] prose prose-sm prose-invert">
          {typeof content === 'string' ? (
            <MarkdownRenderer content={content} />
          ) : (
            content
          )}
        </div>
      )}
    </CardContent>
  </Card>
)

export const SolutionSection = ({
  solution,
  isLoading
}: {
  solution: string
  isLoading: boolean
}) => (
  <Card className="card-premium group hover:shadow-stealth-lg transition-all duration-300 border-emerald-500/20 hover:border-emerald-500/40">
    <CardHeader className="pb-4">
      <CardTitle className="text-sm font-semibold text-foreground tracking-wide flex items-center gap-2 group-hover:text-emerald-400 transition-colors duration-200">
        <div className="w-6 h-6 rounded-lg bg-gradient-to-br from-emerald-500/20 to-emerald-600/10 flex items-center justify-center border border-emerald-500/20 group-hover:border-emerald-500/40 transition-colors duration-200">
          <svg className="w-3 h-3 text-emerald-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
          </svg>
        </div>
        Solution
      </CardTitle>
    </CardHeader>
    <CardContent className="pt-0">
      {isLoading ? (
        <div className="flex items-center gap-3 p-4 bg-emerald-500/5 rounded-lg border border-emerald-500/20">
          <div className="w-4 h-4 border-2 border-emerald-500/30 border-t-emerald-500 rounded-full animate-spin"></div>
          <p className="text-sm text-emerald-200">
            Generating solution...
          </p>
        </div>
      ) : (
        <div className="text-sm leading-relaxed text-foreground/90 max-w-[600px] prose prose-sm prose-invert prose-emerald">
          <MarkdownRenderer content={solution} />
        </div>
      )}
    </CardContent>
  </Card>
)

export const ComplexitySection = ({
  complexity,
  isLoading
}: {
  complexity: string
  isLoading: boolean
}) => (
  <Card className="card-premium group hover:shadow-stealth-lg transition-all duration-300 border-amber-500/20 hover:border-amber-500/40">
    <CardHeader className="pb-4">
      <CardTitle className="text-sm font-semibold text-foreground tracking-wide flex items-center gap-2 group-hover:text-amber-400 transition-colors duration-200">
        <div className="w-6 h-6 rounded-lg bg-gradient-to-br from-amber-500/20 to-amber-600/10 flex items-center justify-center border border-amber-500/20 group-hover:border-amber-500/40 transition-colors duration-200">
          <svg className="w-3 h-3 text-amber-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
          </svg>
        </div>
        Complexity Analysis
      </CardTitle>
    </CardHeader>
    <CardContent className="pt-0">
      {isLoading ? (
        <div className="flex items-center gap-3 p-4 bg-amber-500/5 rounded-lg border border-amber-500/20">
          <div className="w-4 h-4 border-2 border-amber-500/30 border-t-amber-500 rounded-full animate-spin"></div>
          <p className="text-sm text-amber-200">
            Analyzing complexity...
          </p>
        </div>
      ) : (
        <div className="text-sm leading-relaxed text-foreground/90 max-w-[600px] prose prose-sm prose-invert prose-amber">
          <MarkdownRenderer content={complexity} />
        </div>
      )}
    </CardContent>
  </Card>
)

interface SolutionsProps {
  setView?: React.Dispatch<React.SetStateAction<"queue" | "solutions" | "debug">>
}
const Solutions: React.FC<SolutionsProps> = () => {
  const queryClient = useQueryClient()
  const contentRef = useRef<HTMLDivElement>(null)
  const lastSizeRef = useRef<{w: number; h: number}>({ w: 0, h: 0 })
  const resizeTimerRef = useRef<number | null>(null)
  // Let measured toolbar width decide final window size
  const [toolbarWidth, setToolbarWidth] = useState(0)

  // Audio recording state
  const [audioRecording, setAudioRecording] = useState(false)
  const [audioResult, setAudioResult] = useState<AudioResult | null>(null)

  const [debugProcessing, setDebugProcessing] = useState(false)
  const [problemStatementData, setProblemStatementData] =
    useState<ProblemStatementData | null>(null)
  const [solutionData, setSolutionData] = useState<string | null>(null)
  const [thoughtsData, setThoughtsData] = useState<string[] | null>(null)
  const [timeComplexityData, setTimeComplexityData] = useState<string | null>(
    null
  )
  const [spaceComplexityData, setSpaceComplexityData] = useState<string | null>(
    null
  )
  const [customContent, setCustomContent] = useState<string | null>(null)

  const [toastOpen, setToastOpen] = useState(false)
  const [toastMessage, setToastMessage] = useState<ToastMessage>({
    title: "",
    description: "",
    variant: "neutral"
  })

  const [isTooltipVisible, setIsTooltipVisible] = useState(false)
  const [tooltipHeight, setTooltipHeight] = useState(0)

  const [isResetting, setIsResetting] = useState(false)

  const { data: extraScreenshots = [], refetch } = useQuery<Array<{ path: string; preview: string }>, Error>(
    ["extras"],
    async () => {
      try {
        const existing = await window.electronAPI.getScreenshots()
        return existing
      } catch (error) {
        console.error("Error loading extra screenshots:", error)
        return []
      }
    },
    {
      staleTime: Infinity,
      cacheTime: Infinity
    }
  )

  const showToast = (
    title: string,
    description: string,
    variant: ToastVariant
  ) => {
    setToastMessage({ title, description, variant })
    setToastOpen(true)
  }

  const handleDeleteExtraScreenshot = async (index: number) => {
    const screenshotToDelete = extraScreenshots[index]

    try {
      const response = await window.electronAPI.deleteScreenshot(
        screenshotToDelete.path
      )

      if (response.success) {
        refetch() // Refetch screenshots instead of managing state directly
      } else {
        console.error("Failed to delete extra screenshot:", response.error)
      }
    } catch (error) {
      console.error("Error deleting extra screenshot:", error)
    }
  }

  useEffect(() => {
    // Height update logic
    const updateNow = () => {
      if (!contentRef.current) return
      // Use offset sizes and round to avoid subpixel oscillation
      let h = Math.ceil(contentRef.current.offsetHeight)
      const contentW = Math.ceil(contentRef.current.offsetWidth)
      const w = toolbarWidth > 0 ? toolbarWidth : contentW
      if (isTooltipVisible) h += Math.ceil(tooltipHeight)
      const { w: lw, h: lh } = lastSizeRef.current
      if (w === lw && h === lh) return // no change, avoid feedback
      lastSizeRef.current = { w, h }
      window.electronAPI.updateContentDimensions({ width: w, height: h })
    }

    const updateDimensions = () => {
      // Debounce rapid successive measurements during animations/resizes
      if (resizeTimerRef.current) {
        window.clearTimeout(resizeTimerRef.current)
      }
      resizeTimerRef.current = window.setTimeout(updateNow, 50)
    }

    // Initialize resize observer
    const resizeObserver = new ResizeObserver(updateDimensions)
    if (contentRef.current) {
      resizeObserver.observe(contentRef.current)
    }
    updateDimensions()

    // Set up event listeners
    const cleanupFunctions = [
      window.electronAPI.onScreenshotTaken(() => refetch()),
      window.electronAPI.onResetView(() => {
        // Set resetting state first
        setIsResetting(true)

        // Clear the queries
        queryClient.removeQueries(["solution"])
        queryClient.removeQueries(["new_solution"])

        // Reset other states
        refetch()

        // After a small delay, clear the resetting state
        setTimeout(() => {
          setIsResetting(false)
        }, 0)
      }),
      window.electronAPI.onSolutionStart(async () => {
        // Reset UI state for a new solution
        setSolutionData(null)
        setThoughtsData(null)
        setTimeComplexityData(null)
        setSpaceComplexityData(null)
        setCustomContent(null)
        setAudioResult(null)

        // Start audio recording from user's microphone
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
          const mediaRecorder = new MediaRecorder(stream)
          const chunks: Blob[] = []
          mediaRecorder.ondataavailable = (e) => chunks.push(e.data)
          mediaRecorder.start()
          setAudioRecording(true)
          
          // Clear any previous audio UI immediately
          setProblemStatementData(null)
          
          // Record for 5 seconds (or adjust as needed)
          setTimeout(() => mediaRecorder.stop(), 5000)
          mediaRecorder.onstop = async () => {
            setAudioRecording(false)
            const blob = new Blob(chunks, { type: chunks[0]?.type || 'audio/webm' })
            const reader = new FileReader()
            reader.onloadend = async () => {
              const base64Data = (reader.result as string).split(',')[1]
              // Send audio to Gemini for analysis
              try {
                const result = await window.electronAPI.analyzeAudioFromBase64(
                  base64Data,
                  blob.type
                )
                // Store result and update UI
                queryClient.setQueryData(["audio_result"], result)
                setAudioResult(result)
                
                // Clear any intermediate states
                setCustomContent(null)
              } catch (err) {
                console.error('Audio analysis failed:', err)
                showToast(
                  "Audio Analysis Failed", 
                  "Could not process voice input", 
                  "error"
                )
              }
            }
            reader.readAsDataURL(blob)
          }
        } catch (err) {
          console.error('Audio recording error:', err)
          showToast(
            "Recording Failed", 
            "Could not access microphone", 
            "error"
          )
        }
      }),
      //if there was an error processing the initial solution
      window.electronAPI.onSolutionError((error: string) => {
        showToast(
          "Processing Failed",
          "There was an error processing your extra screenshots.",
          "error"
        )
        // Reset solutions in the cache but don't change the view
        const solution = queryClient.getQueryData(["solution"]) as {
          code: string
          thoughts: string[]
          time_complexity: string
          space_complexity: string
        } | null
        
        setSolutionData(solution?.code || null)
        setThoughtsData(solution?.thoughts || null)
        setTimeComplexityData(solution?.time_complexity || null)
        setSpaceComplexityData(solution?.space_complexity || null)
        console.error("Processing error:", error)
      }),
      //when the initial solution is generated, we'll set the solution data to that
      window.electronAPI.onSolutionSuccess((data) => {
        if (!data?.solution) {
          console.warn("Received empty or invalid solution data")
          return
        }

        console.log({ solution: data.solution })

        const solutionData = {
          code: data.solution.code,
          thoughts: data.solution.thoughts,
          time_complexity: data.solution.time_complexity,
          space_complexity: data.solution.space_complexity
        }

        queryClient.setQueryData(["solution"], solutionData)
        setSolutionData(solutionData.code || null)
        setThoughtsData(solutionData.thoughts || null)
        setTimeComplexityData(solutionData.time_complexity || null)
        setSpaceComplexityData(solutionData.space_complexity || null)
      }),

      // Unified mode change handler
      window.electronAPI.onModeChange((mode) => {
        // Clear all UI states when switching modes
        setProblemStatementData(null)
        setSolutionData(null)
        setThoughtsData(null)
        setTimeComplexityData(null)
        setSpaceComplexityData(null)
        setAudioResult(null)
        setCustomContent(null)
        
        if (mode === 'voice') {
          setAudioRecording(false)
        }
      }),

      //########################################################
      //DEBUG EVENTS
      //########################################################
      window.electronAPI.onDebugStart(() => {
        //we'll set the debug processing state to true and use that to render a little loader
        setDebugProcessing(true)
      }),
      //the first time debugging works, we'll set the view to debug and populate the cache with the data
      window.electronAPI.onDebugSuccess((data) => {
        console.log({ debug_data: data })

        queryClient.setQueryData(["new_solution"], data.solution)
        setDebugProcessing(false)
      }),
      //when there was an error in the initial debugging, we'll show a toast and stop the little generating pulsing thing.
      window.electronAPI.onDebugError(() => {
        showToast(
          "Processing Failed",
          "There was an error debugging your code.",
          "error"
        )
        setDebugProcessing(false)
      }),
      window.electronAPI.onProcessingNoScreenshots(() => {
        showToast(
          "No Screenshots",
          "There are no extra screenshots to process.",
          "neutral"
        )
      }),
    ]

    return () => {
      resizeObserver.disconnect()
      if (resizeTimerRef.current) {
        window.clearTimeout(resizeTimerRef.current)
        resizeTimerRef.current = null
      }
      cleanupFunctions.forEach((cleanup) => cleanup())
    }
  }, [isTooltipVisible, tooltipHeight, toolbarWidth])

  useEffect(() => {
    setProblemStatementData(
      queryClient.getQueryData(["problem_statement"]) || null
    )
    setSolutionData(queryClient.getQueryData(["solution"]) || null)

    const unsubscribe = queryClient.getQueryCache().subscribe((event) => {
      if (event?.query.queryKey[0] === "problem_statement") {
        setProblemStatementData(
          queryClient.getQueryData(["problem_statement"]) || null
        )
        // If this is from audio processing, show it in the custom content section
        const audioResult = queryClient.getQueryData(["audio_result"]) as AudioResult | undefined;
        if (audioResult) {
          // Update all relevant sections when audio result is received
          setProblemStatementData({
            problem_statement: audioResult.text,
            input_format: {
              description: "Generated from audio input",
              parameters: []
            },
            output_format: {
              description: "Generated from audio input",
              type: "string",
              subtype: "text"
            },
            complexity: {
              time: "N/A",
              space: "N/A"
            },
            test_cases: [],
            validation_type: "manual",
            difficulty: "custom"
          });
          setSolutionData(null); // Reset solution to trigger loading state
          setThoughtsData(null);
          setTimeComplexityData(null);
          setSpaceComplexityData(null);
        }
      }
      if (event?.query.queryKey[0] === "solution") {
        const solution = queryClient.getQueryData(["solution"]) as {
          code: string
          thoughts: string[]
          time_complexity: string
          space_complexity: string
        } | null

        setSolutionData(solution?.code ?? null)
        setThoughtsData(solution?.thoughts ?? null)
        setTimeComplexityData(solution?.time_complexity ?? null)
        setSpaceComplexityData(solution?.space_complexity ?? null)
      }
    })
    return () => unsubscribe()
  }, [queryClient])

  const handleTooltipVisibilityChange = (visible: boolean, height: number) => {
    setIsTooltipVisible(visible)
    setTooltipHeight(height)
  }

  return (
    <>
      {!isResetting && queryClient.getQueryData(["new_solution"]) ? (
        <>
          <Debug
            isProcessing={debugProcessing}
            setIsProcessing={setDebugProcessing}
          />
        </>
      ) : (
        <div ref={contentRef} className="relative inline-block w-fit space-y-3 px-4 py-3">
          <Toast
            open={toastOpen}
            onOpenChange={setToastOpen}
            variant={toastMessage.variant}
            duration={3000}
          >
            <ToastTitle>{toastMessage.title}</ToastTitle>
            <ToastDescription>{toastMessage.description}</ToastDescription>
          </Toast>

          {/* Conditionally render the screenshot queue if solutionData is available */}
          {solutionData && (
            <div className="bg-transparent w-fit">
              <div className="pb-3">
                <div className="space-y-3 w-fit">
                  <ScreenshotQueue
                    isLoading={debugProcessing}
                    screenshots={extraScreenshots}
                    onDeleteScreenshot={handleDeleteExtraScreenshot}
                  />
                </div>
              </div>
            </div>
          )}

          {/* Unified modern toolbar (reuse QueueCommands for consistent UI) */}
          <div className="w-fit">
            <QueueCommands
              isRecording={audioRecording}
              onToggleRecording={() => setAudioRecording((r) => !r)}
              onCaptureAndSolve={async () => {
                try {
                  await window.electronAPI.takeScreenshot()
                } catch (e) {
                  console.error(e)
                }
              }}
              isVisible={true}
              onClose={() => window.electronAPI.toggleApp()}
              onChatToggle={() => {}}
              onSettingsToggle={() => {}}
              onTranscriptToggle={() => {}}
              onStealthToggle={() => {}}
              onMeasureWidth={(w) => setToolbarWidth((prev) => Math.max(prev, w))}
              positionFixed={false}
            />
          </div>

          {problemStatementData?.validation_type === "manual" ? (
              <ContentSection
                title={problemStatementData?.output_format?.subtype === "voice" ? "Audio Result" : "Screenshot Result"}
                content={problemStatementData.problem_statement}
                isLoading={false}
              />
            ) : (
              <>
                {/* Problem Statement Section - Only for non-manual */}
                <ContentSection
                  title={problemStatementData?.output_format?.subtype === "voice" ? "Voice Input" : "Problem Statement"}
                  content={problemStatementData?.problem_statement}
                  isLoading={!problemStatementData}
                />
                {/* Show loading state when waiting for solution */}
                {problemStatementData && !solutionData && (
                  <Card className="card-floating">
                    <CardContent className="p-4 flex">
                      <p className="text-xs text-muted-foreground animate-pulse">
                        {problemStatementData?.output_format?.subtype === "voice" 
                          ? "Processing voice input..." 
                          : "Generating solutions..."}
                      </p>
                    </CardContent>
                  </Card>
                )}
                {/* Solution Sections (legacy, only for non-manual) */}
                {solutionData && (
                  <>
                    <ContentSection
                      title="Analysis"
                      content={
                        thoughtsData && (
                          <div className="space-y-3">
                            <div className="space-y-1">
                              {thoughtsData.map((thought, index) => (
                                <div
                                  key={index}
                                  className="flex items-start gap-2"
                                >
                                  <div className="w-1 h-1 rounded-full bg-blue-400/80 mt-2 shrink-0" />
                                  <div>{thought}</div>
                                </div>
                              ))}
                            </div>
                          </div>
                        )
                      }
                      isLoading={!thoughtsData}
                    />
                    <SolutionSection
                      solution={solutionData}
                      isLoading={!solutionData}
                    />
                    {problemStatementData?.output_format?.subtype !== "voice" && (
                      <ComplexitySection
                        complexity={`**Time Complexity:** ${timeComplexityData || 'Analyzing...'}

**Space Complexity:** ${spaceComplexityData || 'Analyzing...'}`}
                        isLoading={!timeComplexityData || !spaceComplexityData}
                      />
                    )}
                  </>
                )}
              </>
            )}
        </div>
      )}
    </>
  )
}

export default Solutions

===== END FILE: src\_pages\Solutions.tsx =====

===== BEGIN FILE: src\components\Queue\QueueCommands.tsx =====
import React, { useState, useRef, useEffect } from 'react'
import { IoLogOutOutline } from 'react-icons/io5'
import { RiEyeLine, RiEyeOffLine } from 'react-icons/ri'
import { Button } from '../ui/button'
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '../ui/tooltip'
import { Separator } from '../ui/separator'
// MindWhisper brand logo for Live Mode button
import mindwhisperLogo from '../../../logo mindwhisper.webp'

interface QueueCommandsProps {
  isRecording: boolean;
  onToggleRecording: () => void;
  onCaptureAndSolve: () => void;
  isVisible: boolean;
  onClose: () => void;
  onChatToggle: () => void;
  onSettingsToggle: () => void;
  onTranscriptToggle: () => void;
  onStealthToggle?: () => void;
  onMeasureWidth?: (width: number) => void;
  // Render toolbar as fixed overlay (default) or inline block within layout
  positionFixed?: boolean;
  // Optional props that may be passed but aren't used
  screenshots?: string[];
  onMinimize?: () => void;
  onTooltipVisibilityChange?: () => void;
  stealthEnabled?: boolean;
}

const QueueCommands: React.FC<QueueCommandsProps> = ({
  isRecording,
  onToggleRecording,
  onCaptureAndSolve,
  isVisible,
  onChatToggle,
  onSettingsToggle,
  onTranscriptToggle,
  onStealthToggle,
  onMeasureWidth,
  positionFixed = true,
  stealthEnabled,
}) => {
  const [isTooltipVisible, setIsTooltipVisible] = useState(false)
  const tooltipRef = useRef<HTMLDivElement>(null)
  const toolbarRef = useRef<HTMLDivElement>(null)
  const timeoutRef = useRef<NodeJS.Timeout>()

  const handleMouseEnter = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
    }
    setIsTooltipVisible(true)
  }

  const handleMouseLeave = () => {
    timeoutRef.current = setTimeout(() => {
      setIsTooltipVisible(false)
    }, 300)
  }

  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
      }
    }
  }, [])

  // Report toolbar width to parent so window can size correctly (fixed elements don't affect layout size)
  useEffect(() => {
    if (!toolbarRef.current || !onMeasureWidth) return
    const el = toolbarRef.current
    const report = () => {
      // Measure multiple ways and add a buffer so borders/blur/shadows don't clip
      const rectW = el.getBoundingClientRect().width
      const sw = el.scrollWidth
      const ow = el.offsetWidth
      const base = Math.max(rectW, sw, ow)
      const w = Math.ceil(base + 48) // larger buffer to match hover-perfect layout
      onMeasureWidth(w)
    }
    const ro = new ResizeObserver(report)
    ro.observe(el)
    // Report twice to catch first paint and any late icon/font layout
    report()
    requestAnimationFrame(report)
    const t1 = setTimeout(report, 150)
    const t2 = setTimeout(report, 500)
    const t3 = setTimeout(report, 1000)
    // Also re-measure after fonts load (hover often forces reflow that fonts loading would also cause)
    let fontReady = false
    if ((document as any).fonts && typeof (document as any).fonts.ready?.then === 'function') {
      ;(document as any).fonts.ready.then(() => {
        fontReady = true
        report()
      })
    }

    return () => {
      ro.disconnect();
      clearTimeout(t1);
      clearTimeout(t2);
      clearTimeout(t3);
    }
  }, [onMeasureWidth])

  const containerClass = positionFixed
    ? `fixed top-4 left-1/2 transform -translate-x-1/2 z-50 ${isVisible ? 'opacity-100' : 'opacity-0 pointer-events-none'} transition-opacity duration-150`
    : `relative inline-block my-2 ${isVisible ? '' : 'opacity-0 pointer-events-none'}`;

  return (
    <div ref={toolbarRef} className={containerClass}>
      <div className="floating-toolbar relative flex items-center px-3 py-2 w-auto whitespace-nowrap overflow-visible">
        {typeof stealthEnabled === 'boolean' && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <button
                  type="button"
                  className={`app-region-no-drag absolute top-1.5 right-2 flex h-7 w-7 items-center justify-center rounded-full border text-xs transition-colors shadow-sm ${stealthEnabled
                    ? 'border-emerald-400/60 text-emerald-200 bg-emerald-400/15 hover:bg-emerald-400/25'
                    : 'border-amber-400/60 text-amber-200 bg-amber-400/15 hover:bg-amber-400/25'
                  }`}
                  aria-label={stealthEnabled ? 'Invisible on screen shares' : 'Visible on screen shares'}
                  tabIndex={-1}
                >
                  {stealthEnabled ? <RiEyeOffLine className="h-4 w-4" /> : <RiEyeLine className="h-4 w-4" />}
                </button>
              </TooltipTrigger>
              <TooltipContent side="bottom" align="end">
                <p>{stealthEnabled ? 'Invisible on screen shares' : 'Visible on screen shares'}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Left spacer to avoid initial clipping */}
        <div className="w-3 shrink-0" aria-hidden="true" />
        
        {/* Left Section - Secondary Actions */}
        <div className="flex items-center gap-1">
          {/* Drag Handle (replaces Toggle) */}
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                {/* Use a div, not a button, so it remains draggable */}
                <div
                  className="drag-handle app-region-drag toolbar-btn group h-auto px-2 py-1 flex-col min-w-[60px] select-none"
                  role="button"
                  aria-label="Drag to move window"
                  title="Drag to move the app"
                >
                  <div className="icon-container">
                    {/* Move/Drag icon (four arrows) */}
                    <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 10H5l4-4 4 4h-2v4h2l-4 4-4-4h2v-4zM14 7V5l4 4-4 4V11h-4v2l-4-4 4-4v2h4z" />
                    </svg>
                  </div>
                  <span className="text-xs font-medium">Move</span>
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Hold and drag to move the application window</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          {/* Solve Button (Capture + Send) */}
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="sm"
                  className="toolbar-btn app-region-no-drag group h-auto px-2 py-1 flex-col min-w-[60px] hover:scale-105 transition-all duration-200 hover:shadow-stealth-md"
                  onClick={onCaptureAndSolve}
                >
                  <div className="icon-container relative">
                    <svg className="w-3 h-3 transition-transform duration-200 group-hover:scale-110" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" />
                    </svg>
                    <div className="absolute -top-0.5 -right-0.5 w-1.5 h-1.5 bg-emerald-400 rounded-full opacity-0 group-hover:opacity-100 animate-pulse transition-opacity duration-200"></div>
                  </div>
                  <span className="text-xs font-medium group-hover:font-semibold transition-all duration-200">Solve</span>
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Capture & Solve (Ctrl+H)</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          {/* Voice Button */}
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="sm"
                  className={`toolbar-btn app-region-no-drag group h-auto px-2 py-1 flex-col min-w-[60px] hover:scale-105 transition-all duration-200 ${
                    isRecording ? 'text-red-400 bg-red-400/10 shadow-red-400/20 shadow-lg animate-pulse' : 'hover:shadow-stealth-md'
                  }`}
                  onClick={onToggleRecording}
                >
                  <div className="icon-container relative">
                    {isRecording ? (
                      <>
                        <div className="w-3 h-3 bg-red-400 rounded-full animate-pulse" />
                        <div className="absolute inset-0 w-3 h-3 bg-red-400/30 rounded-full animate-ping"></div>
                      </>
                    ) : (
                      <>
                        <svg className="w-3 h-3 transition-transform duration-200 group-hover:scale-110" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                        </svg>
                        <div className="absolute -top-0.5 -right-0.5 w-1.5 h-1.5 bg-blue-400 rounded-full opacity-0 group-hover:opacity-100 animate-pulse transition-opacity duration-200"></div>
                      </>
                    )}
                  </div>
                  <span className="text-xs font-medium group-hover:font-semibold transition-all duration-200">{isRecording ? 'Recording' : 'Voice'}</span>
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Voice Recording</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

        </div>

        <Separator orientation="vertical" className="h-8" />
        {/* Right spacer to avoid initial clipping */}
        <div className="w-3 shrink-0" aria-hidden="true" />

        {/* CENTER - Main Feature: Live Mode Transcription */}
        <div className="flex justify-center">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="default"
                  size="sm"
                  className="live-mode-btn app-region-no-drag live-mode-breathing h-auto bg-white text-black shadow-sm hover:shadow-md transition-shadow group"
                  onClick={onTranscriptToggle}
                >
                  <div className="flex flex-col items-center gap-2 py-2">
                    <div className="live-mode-icon rounded-full bg-white w-8 h-8 flex items-center justify-center shadow-sm">
                      <img
                        src={mindwhisperLogo}
                        alt="MindWhisper Live"
                        className="w-6 h-6 object-contain select-none will-change-transform transition-transform duration-500 ease-out group-hover:scale-105"
                        draggable={false}
                      />
                    </div>
                    <span className="live-mode-label text-base">Live Mode</span>
                  </div>
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>üöÄ Live Mode Transcription - Our Main Feature!</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </div>

        <Separator orientation="vertical" className="h-8" />
        {/* Right spacer to match the left spacer around the Live Mode button */}
        <div className="w-3 shrink-0" aria-hidden="true" />

        {/* Right Section - Secondary Actions */}
        <div className="flex items-center gap-1">
          {/* Chat Button */}
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="sm"
                  className="toolbar-btn app-region-no-drag group h-auto px-2 py-1 flex-col min-w-[60px] hover:scale-105 transition-all duration-200 hover:shadow-stealth-md"
                  onClick={onChatToggle}
                >
                  <div className="icon-container relative">
                    <svg className="w-3 h-3 transition-transform duration-200 group-hover:scale-110" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                    </svg>
                    <div className="absolute -top-0.5 -right-0.5 w-1.5 h-1.5 bg-purple-400 rounded-full opacity-0 group-hover:opacity-100 animate-pulse transition-opacity duration-200"></div>
                  </div>
                  <span className="text-xs font-medium group-hover:font-semibold transition-all duration-200">Chat</span>
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Open Chat</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          {/* Settings Button */}
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="sm"
                  className="toolbar-btn app-region-no-drag group h-auto px-2 py-1 flex-col min-w-[60px]"
                  onClick={onSettingsToggle}
                >
                  <div className="icon-container">
                    {/* Keyboard / shortcuts icon */}
                    <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <rect x="3" y="7" width="18" height="10" rx="2" ry="2" strokeWidth="2"/>
                      <path strokeWidth="2" d="M6 10h2M10 10h2M14 10h2M18 10h0M6 13h3M10.5 13h3M15 13h3" strokeLinecap="round"/>
                    </svg>
                  </div>
                  <span className="text-xs font-medium">Shortcuts</span>
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Keyboard Shortcuts</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          {/* Stealth Button */}
          {onStealthToggle && (
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="toolbar-btn app-region-no-drag group h-auto px-2 py-1 flex-col min-w-[60px]"
                    onClick={onStealthToggle}
                  >
                    <div className="icon-container">
                      <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L12 12m6.121-6.121A2.98 2.98 0 0119 8c0 .597-.176 1.152-.487 1.618m-7.681 8.207l6.294-6.294" />
                      </svg>
                    </div>
                    <span className="text-xs font-medium">Stealth</span>
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>Stealth Controls</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          )}

          {/* Quit Button */}
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="sm"
                  className="toolbar-btn app-region-no-drag group h-auto px-2 py-1 flex-col min-w-[60px]"
                  onClick={() => {
                    try { window.electronAPI.quitApp() } catch {}
                  }}
                  aria-label="Quit MindWhisper AI"
                >
                  <div className="icon-container">
                    <IoLogOutOutline className="w-3 h-3" />
                  </div>
                  <span className="text-xs font-medium">Quit</span>
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Exit MindWhisper AI</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

        </div>

        {/* Audio Result Display - Hidden for now */}
        {false && (
          <div className="mt-4 w-full max-w-md">
            <div className="card p-4 space-y-3">
              <div className="flex items-center space-x-3">
                <div className="w-8 h-8 rounded-full bg-black flex items-center justify-center">
                  <svg className="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                  </svg>
                </div>
                <div>
                  <h4 className="text-sm font-semibold">Voice Analysis</h4>
                  <p className="text-xs text-black/60">Transcription completed</p>
                </div>
                <button
                  onClick={() => {/* Clear result */}}
                  className="ml-auto btn btn-ghost btn-sm p-1 hover:bg-black/10"
                  title="Clear result"
                >
                  <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              </div>
              <div className="bg-black/5 rounded-lg p-3 border border-black/10">
                <p className="text-sm leading-relaxed">Audio result placeholder</p>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}

export { QueueCommands as default }

===== END FILE: src\components\Queue\QueueCommands.tsx =====

===== BEGIN FILE: src\components\Queue\ScreenshotItem.tsx =====
// src/components/ScreenshotItem.tsx
import React from "react"
import { X } from "lucide-react"
import { Button } from "../ui/button"

interface Screenshot {
  path: string
  preview: string
}

interface ScreenshotItemProps {
  screenshot: Screenshot
  onDelete: (index: number) => void
  index: number
  isLoading: boolean
}

const ScreenshotItem: React.FC<ScreenshotItemProps> = ({
  screenshot,
  onDelete,
  index,
  isLoading
}) => {
  const handleDelete = async () => {
    await onDelete(index)
  }

  return (
    <>
      <div
        className={`relative overflow-hidden rounded-lg card-premium border border-stealth ${isLoading ? "" : "group hover:shadow-[var(--stealth-shadow-medium)] hover:-translate-y-0.5 transition-all duration-200 ease-out"}`}
      >
        <div className="w-full h-full relative">
          {isLoading && (
            <div className="absolute inset-0 z-10 flex items-center justify-center bg-black/40 backdrop-blur-sm border-b border-white/10">
              <div className="w-6 h-6 border-2 border-white/80 border-t-transparent rounded-full animate-spin" />
            </div>
          )}
          <img
            src={screenshot.preview}
            alt="Screenshot"
            className={`w-full h-full object-cover transition-all duration-300 ${
              isLoading
                ? "opacity-60"
                : "cursor-pointer group-hover:scale-[1.03] group-hover:brightness-90"
            }`}
          />
        </div>
        {!isLoading && (
          <Button
            onClick={(e) => {
              e.stopPropagation()
              handleDelete()
            }}
            variant="ghost"
            size="icon"
            className="absolute top-2 left-2 p-1 rounded-full bg-black/50 text-white opacity-0 group-hover:opacity-100 transition-opacity duration-300 h-8 w-8 border border-white/10"
            aria-label="Delete screenshot"
          >
            <X size={16} />
          </Button>
        )}
      </div>
    </>
  )
}

export default ScreenshotItem

===== END FILE: src\components\Queue\ScreenshotItem.tsx =====

===== BEGIN FILE: src\components\Queue\ScreenshotQueue.tsx =====
import React from "react"
import ScreenshotItem from "./ScreenshotItem"

interface Screenshot {
  path: string
  preview: string
}

interface ScreenshotQueueProps {
  isLoading: boolean
  screenshots: Screenshot[]
  onDeleteScreenshot: (index: number) => void
}
const ScreenshotQueue: React.FC<ScreenshotQueueProps> = ({
  isLoading,
  screenshots,
  onDeleteScreenshot
}) => {
  if (screenshots.length === 0) {
    return <></>
  }

  const displayScreenshots = screenshots.slice(0, 5)

  return (
    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-3 sm:gap-3.5 md:gap-4">
      {displayScreenshots.map((screenshot, index) => (
        <ScreenshotItem
          key={screenshot.path}
          isLoading={isLoading}
          screenshot={screenshot}
          index={index}
          onDelete={onDeleteScreenshot}
        />
      ))}
    </div>
  )
}

export default ScreenshotQueue

===== END FILE: src\components\Queue\ScreenshotQueue.tsx =====

===== BEGIN FILE: src\components\Solutions\SolutionCommands.tsx =====
import React, { useState, useEffect, useRef } from "react"
import { IoLogOutOutline } from "react-icons/io5"
import { Button } from "../ui/button"

interface SolutionCommandsProps {
  extraScreenshots: any[]
  onTooltipVisibilityChange?: (visible: boolean, height: number) => void
}

const SolutionCommands: React.FC<SolutionCommandsProps> = ({
  extraScreenshots,
  onTooltipVisibilityChange
}) => {
  const [isTooltipVisible, setIsTooltipVisible] = useState(false)
  const tooltipRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    if (onTooltipVisibilityChange) {
      let tooltipHeight = 0
      if (tooltipRef.current && isTooltipVisible) {
        tooltipHeight = tooltipRef.current.offsetHeight + 10 // Adjust if necessary
      }
      onTooltipVisibilityChange(isTooltipVisible, tooltipHeight)
    }
  }, [isTooltipVisible, onTooltipVisibilityChange])

  const handleMouseEnter = () => {
    setIsTooltipVisible(true)
  }

  const handleMouseLeave = () => {
    setIsTooltipVisible(false)
  }

  return (
    <div>
      <div className="pt-2 w-fit">
        <div className="text-xs text-white/90 backdrop-blur-md bg-black/60 rounded-lg py-2 px-4 flex items-center justify-center gap-4">
          {/* Show/Hide */}
          <div className="flex items-center gap-2 whitespace-nowrap">
            <span className="text-[11px] leading-none">Show/Hide</span>
            <div className="flex gap-1">
              <button className="bg-white/10 hover:bg-white/20 transition-colors rounded-md px-1.5 py-1 text-[11px] leading-none text-white/70">
                ‚åò
              </button>
              <button className="bg-white/10 hover:bg-white/20 transition-colors rounded-md px-1.5 py-1 text-[11px] leading-none text-white/70">
                B
              </button>
            </div>
          </div>

          {/* Screenshot */}
          <div className="flex items-center gap-2 whitespace-nowrap">
            <span className="text-[11px] leading-none truncate">
              {extraScreenshots.length === 0
                ? "Screenshot your code"
                : "Screenshot"}
            </span>
            <div className="flex gap-1">
              <button className="bg-white/10 hover:bg-white/20 transition-colors rounded-md px-1.5 py-1 text-[11px] leading-none text-white/70">
                ‚åò
              </button>
              <button className="bg-white/10 hover:bg-white/20 transition-colors rounded-md px-1.5 py-1 text-[11px] leading-none text-white/70">
                H
              </button>
            </div>
          </div>
          {extraScreenshots.length > 0 && (
            <div className="flex items-center gap-2 whitespace-nowrap">
              <span className="text-[11px] leading-none">Debug</span>
              <div className="flex gap-1">
                <button className="bg-white/10 hover:bg-white/20 transition-colors rounded-md px-1.5 py-1 text-[11px] leading-none text-white/70">
                  ‚åò
                </button>
                <button className="bg-white/10 hover:bg-white/20 transition-colors rounded-md px-1.5 py-1 text-[11px] leading-none text-white/70">
                  ‚Üµ
                </button>
              </div>
            </div>
          )}

          {/* Start Over */}
          <div className="flex items-center gap-2 whitespace-nowrap">
            <span className="text-[11px] leading-none">Start over</span>
            <div className="flex gap-1">
              <button className="bg-white/10 hover:bg-white/20 transition-colors rounded-md px-1.5 py-1 text-[11px] leading-none text-white/70">
                ‚åò
              </button>
              <button className="bg-white/10 hover:bg-white/20 transition-colors rounded-md px-1.5 py-1 text-[11px] leading-none text-white/70">
                R
              </button>
            </div>
          </div>

          {/* Question Mark with Tooltip */}
          <div
            className="relative inline-block"
            onMouseEnter={handleMouseEnter}
            onMouseLeave={handleMouseLeave}
          >
            {/* Question mark circle */}
            <div className="w-6 h-6 rounded-full bg-white/10 hover:bg-white/20 backdrop-blur-sm transition-colors flex items-center justify-center cursor-help z-10">
              <span className="text-xs text-white/70">?</span>
            </div>

            {/* Tooltip Content */}
            {isTooltipVisible && (
              <div
                ref={tooltipRef}
                className="absolute top-full right-0 mt-2 w-80"
                style={{ zIndex: 100 }}
              >
                <div className="p-3 text-xs bg-black/80 backdrop-blur-md rounded-lg border border-white/10 text-white/90 shadow-lg">
                  {/* Tooltip content */}
                  <div className="space-y-4">
                    <h3 className="font-medium whitespace-nowrap">
                      Keyboard Shortcuts
                    </h3>
                    <div className="space-y-3">
                      {/* Toggle Command */}
                      <div className="space-y-1">
                        <div className="flex items-center justify-between">
                          <span className="whitespace-nowrap">
                            Toggle Window
                          </span>
                          <div className="flex gap-1">
                            <span className="bg-white/10 px-1.5 py-0.5 rounded text-[10px] leading-none">
                              ‚åò
                            </span>
                            <span className="bg-white/10 px-1.5 py-0.5 rounded text-[10px] leading-none">
                              B
                            </span>
                          </div>
                        </div>
                        <p className="text-[10px] leading-relaxed text-white/70 whitespace-nowrap truncate">
                          Show or hide this window.
                        </p>
                      </div>
                      {/* Screenshot Command */}
                      <div className="space-y-1">
                        <div className="flex items-center justify-between">
                          <span className="whitespace-nowrap">
                            Take Screenshot
                          </span>
                          <div className="flex gap-1">
                            <span className="bg-white/10 px-1.5 py-0.5 rounded text-[10px] leading-none">
                              ‚åò
                            </span>
                            <span className="bg-white/10 px-1.5 py-0.5 rounded text-[10px] leading-none">
                              H
                            </span>
                          </div>
                        </div>
                        <p className="text-[10px] leading-relaxed text-white/70 whitespace-nowrap truncate">
                          Capture additional parts of the question or your
                          solution for debugging help. Up to 5 extra screenshots
                          are saved.
                        </p>
                      </div>
                      {/* Debug Command */}
                      <div className="space-y-1">
                        <div className="flex items-center justify-between">
                          <span className="whitespace-nowrap">Debug</span>
                          <div className="flex gap-1">
                            <span className="bg-white/10 px-1.5 py-0.5 rounded text-[10px] leading-none">
                              ‚åò
                            </span>
                            <span className="bg-white/10 px-1.5 py-0.5 rounded text-[10px] leading-none">
                              ‚Üµ
                            </span>
                          </div>
                        </div>
                        <p className="text-[10px] leading-relaxed text-white/70 whitespace-nowrap truncate">
                          Generate new solutions based on all previous and newly
                          added screenshots.
                        </p>
                      </div>
                      {/* Start Over Command */}
                      <div className="space-y-1">
                        <div className="flex items-center justify-between">
                          <span className="whitespace-nowrap">Start Over</span>
                          <div className="flex gap-1">
                            <span className="bg-white/10 px-1.5 py-0.5 rounded text-[10px] leading-none">
                              ‚åò
                            </span>
                            <span className="bg-white/10 px-1.5 py-0.5 rounded text-[10px] leading-none">
                              R
                            </span>
                          </div>
                        </div>
                        <p className="text-[10px] leading-relaxed text-white/70 whitespace-nowrap truncate">
                          Start fresh with a new question.
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Sign Out Button */}
          <Button
            variant="ghost"
            size="icon"
            className="text-red-500/70 hover:text-red-500/90 transition-colors hover:cursor-pointer h-6 w-6"
            title="Sign Out"
            onClick={() => window.electronAPI.quitApp()}
          >
            <IoLogOutOutline className="w-4 h-4" />
          </Button>
        </div>
      </div>
    </div>
  )
}

export default SolutionCommands

===== END FILE: src\components\Solutions\SolutionCommands.tsx =====

===== BEGIN FILE: src\components\Transcription\ImprovedLiveTranscriptPanel.tsx =====
import React, { useEffect, useMemo, useRef, useState } from "react";
import { Button } from "../ui/button";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "../ui/card";

interface WordTs { word: string; start: number; end: number }
interface TranscriptResult { id: string; text: string; words?: WordTs[] }

interface ActionCommand {
  command_text: string
  timestamp: string
  who_said_it: string
  suggested_response: string
  polished_response?: string
}

/**
 * Optimized audio processing functions for Moonshine
 */
const AudioUtils = {
  SAMPLE_RATE: 16000, // Moonshine expects 16kHz
  CHUNK_DURATION: 1.5, // Reduced latency

  processAudioChunk(channels: Float32Array[], originalSampleRate: number): Float32Array {
    if (channels.length === 0) return new Float32Array(0);

    // Convert to mono by averaging channels
    const monoData = new Float32Array(channels[0].length);
    for (let i = 0; i < channels[0].length; i++) {
      let sum = 0;
      for (let ch = 0; ch < channels.length; ch++) {
        sum += channels[ch][i] || 0;
      }
      monoData[i] = sum / channels.length;
    }

    // Resample to 16kHz if needed
    if (originalSampleRate !== this.SAMPLE_RATE) {
      return this.resample(monoData, originalSampleRate, this.SAMPLE_RATE);
    }

    return monoData;
  },

  resample(input: Float32Array, inputRate: number, outputRate: number): Float32Array {
    if (inputRate === outputRate) return input;

    const ratio = inputRate / outputRate;
    const outputLength = Math.floor(input.length / ratio);
    const output = new Float32Array(outputLength);

    for (let i = 0; i < outputLength; i++) {
      const srcIndex = i * ratio;
      const srcIndexFloor = Math.floor(srcIndex);
      const srcIndexCeil = Math.min(srcIndexFloor + 1, input.length - 1);
      const fraction = srcIndex - srcIndexFloor;

      output[i] = input[srcIndexFloor] * (1 - fraction) + input[srcIndexCeil] * fraction;
    }

    return output;
  },

  encodeWavBase64(audioData: Float32Array, sampleRate?: number): string {
    const sr = sampleRate ?? AudioUtils.SAMPLE_RATE
    const length = audioData.length;
    const buffer = new ArrayBuffer(44 + length * 2);
    const view = new DataView(buffer);

    // WAV header
    const writeString = (offset: number, string: string) => {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    };

    writeString(0, 'RIFF');
    view.setUint32(4, 36 + length * 2, true);
    writeString(8, 'WAVE');
    writeString(12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, sr, true);
    view.setUint32(28, sr * 2, true);
    view.setUint16(32, 2, true);
    view.setUint16(34, 16, true);
    writeString(36, 'data');
    view.setUint32(40, length * 2, true);

    // Convert float32 to int16
    let offset = 44;
    for (let i = 0; i < length; i++) {
      const sample = Math.max(-1, Math.min(1, audioData[i]));
      view.setInt16(offset, sample * 0x7FFF, true);
      offset += 2;
    }

    // Convert to base64
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  },

  detectSilence(audioData: Float32Array, threshold: number = 0.01): boolean {
    let sum = 0;
    for (let i = 0; i < audioData.length; i++) {
      sum += Math.abs(audioData[i]);
    }
    const average = sum / audioData.length;
    return average < threshold;
  }
};

const ImprovedLiveTranscriptPanel: React.FC = () => {
  const [isRunning, setIsRunning] = useState(false)
  const [activeTab, setActiveTab] = useState<'transcript'|'commands'>('transcript')
  const [engineStatus, setEngineStatus] = useState<string>('Stopped')

  // Transcript state
  const [transcript, setTranscript] = useState<string>("")
  const [history, setHistory] = useState<Array<{ text: string; start: number; end: number }>>([])
  const [commands, setCommands] = useState<ActionCommand[]>([])

  // Streaming capture
  const mediaStreamRef = useRef<MediaStream|null>(null)
  const audioCtxRef = useRef<AudioContext|null>(null)
  const processorRef = useRef<ScriptProcessorNode|null>(null)
  const audioBufferRef = useRef<Float32Array>(new Float32Array(0))
  const sampleRateRef = useRef<number>(48000)
  const totalFramesSentRef = useRef<number>(0)
  const lastSpeechTimeRef = useRef<number>(Date.now())
  const pendingUtteranceRef = useRef<string>("")

  // Performance monitoring
  const [processingStats, setProcessingStats] = useState({
    chunksProcessed: 0,
    avgLatency: 0,
    lastProcessTime: 0
  })

  const resetBuffers = () => {
    audioBufferRef.current = new Float32Array(0)
    totalFramesSentRef.current = 0
  }

  const stopCapture = async () => {
    try {
      processorRef.current?.disconnect()
      processorRef.current = null
      audioCtxRef.current?.close().catch(() => {})
      audioCtxRef.current = null
      mediaStreamRef.current?.getTracks().forEach(t => t.stop())
      mediaStreamRef.current = null
      resetBuffers()
      
      setEngineStatus('Stopping...')
      await window.electronAPI.stopLiveTranscript()
      setEngineStatus('Stopped')
      setIsRunning(false)
    } catch (error) {
      console.error('Error stopping capture:', error)
      setEngineStatus('Error stopping')
    }
  }

  const startCapture = async () => {
    try {
      setEngineStatus('Starting Moonshine engine...')
      
      // Start Moonshine backend engine
      const started = await window.electronAPI.startLiveTranscript()
      if (!started?.success) {
        throw new Error(started?.error || 'Failed to start Moonshine backend')
      }
      
      setEngineStatus('Requesting audio access...')

      // Request system audio via display media
      const displayStream = await // @ts-ignore - Chromium supports audio in getDisplayMedia
        navigator.mediaDevices.getDisplayMedia({ 
          audio: {
            channelCount: 1, // Request mono audio
            sampleRate: AudioUtils.SAMPLE_RATE, // Request 16kHz if possible
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false
          }, 
          video: false as any 
        })
      
      mediaStreamRef.current = displayStream
      setEngineStatus('Setting up audio processing...')

      const audioCtx = new (window.AudioContext || (window as any).webkitAudioContext)()
      audioCtxRef.current = audioCtx
      sampleRateRef.current = audioCtx.sampleRate

      const source = audioCtx.createMediaStreamSource(displayStream)
      // Smaller buffer size for lower latency
      const processor = audioCtx.createScriptProcessor(2048, 2, 2)
      processorRef.current = processor

      processor.onaudioprocess = async (e) => {
        const startTime = performance.now()
        const input = e.inputBuffer
        const channels: Float32Array[] = []
        
        for (let ch = 0; ch < input.numberOfChannels; ch++) {
          const data = new Float32Array(input.length)
          input.copyFromChannel(data, ch, 0)
          channels.push(data)
        }

        // Process audio with optimized pipeline
        const processedAudio = AudioUtils.processAudioChunk(channels, sampleRateRef.current)
        
        // Skip if silent
        if (AudioUtils.detectSilence(processedAudio)) {
          return
        }

        // Append to buffer
        const newBuffer = new Float32Array(audioBufferRef.current.length + processedAudio.length)
        newBuffer.set(audioBufferRef.current, 0)
        newBuffer.set(processedAudio, audioBufferRef.current.length)
        audioBufferRef.current = newBuffer

        // Check if we have enough data for a chunk
        const framesPerChunk = Math.floor(AudioUtils.CHUNK_DURATION * AudioUtils.SAMPLE_RATE)
        
        if (audioBufferRef.current.length >= framesPerChunk) {
          const chunk = audioBufferRef.current.slice(0, framesPerChunk)
          const remainder = audioBufferRef.current.slice(framesPerChunk)
          audioBufferRef.current = remainder

          try {
            const base64 = AudioUtils.encodeWavBase64(chunk, AudioUtils.SAMPLE_RATE)
            const id = `moonshine-${Date.now()}-${totalFramesSentRef.current}`
            
            const res: TranscriptResult = await window.electronAPI.sendTranscriptChunk(id, base64)
            
            const offsetSec = totalFramesSentRef.current / AudioUtils.SAMPLE_RATE
            totalFramesSentRef.current += framesPerChunk

            const words = (res.words || []).map(w => ({ 
              word: w.word, 
              start: w.start + offsetSec, 
              end: w.end + offsetSec 
            }))

            if (res.text && res.text.trim()) {
              lastSpeechTimeRef.current = Date.now()
              setTranscript(prev => (prev ? prev + ' ' : '') + res.text.trim())
              pendingUtteranceRef.current = (pendingUtteranceRef.current ? pendingUtteranceRef.current + ' ' : '') + res.text.trim()
              
              if (words.length > 0) {
                const segStart = words[0].start
                const segEnd = words[words.length - 1].end
                setHistory(prev => [...prev, { text: res.text.trim(), start: segStart, end: segEnd }])
              }
            }

            // Update performance stats
            const processingTime = performance.now() - startTime
            setProcessingStats(prev => ({
              chunksProcessed: prev.chunksProcessed + 1,
              avgLatency: (prev.avgLatency + processingTime) / 2,
              lastProcessTime: processingTime
            }))

          } catch (error) {
            console.error('Error processing audio chunk:', error)
          }
        }
      }

      source.connect(processor)
      processor.connect(audioCtx.destination)

      setIsRunning(true)
      setEngineStatus('Live transcription active')
      lastSpeechTimeRef.current = Date.now()

    } catch (err) {
      console.error('Start capture failed:', err)
      setEngineStatus(`Error: ${err instanceof Error ? err.message : 'Unknown error'}`)
      await stopCapture()
    }
  }

  // Pause detection and command extraction
  useEffect(() => {
    if (!isRunning) return
    
    const interval = setInterval(async () => {
      const now = Date.now()
      const silenceThreshold = 2500 // Reduced from 3000ms for faster response
      
      if (now - lastSpeechTimeRef.current >= silenceThreshold && pendingUtteranceRef.current.trim().length > 0) {
        const utterance = pendingUtteranceRef.current.trim()
        const timestampISO = new Date().toISOString()
        
        try {
          const cmds = await window.electronAPI.extractCommands(utterance, timestampISO)
          if (cmds && Array.isArray(cmds) && cmds.length > 0) {
            setCommands(prev => [...cmds, ...prev])
          }
        } catch (error) {
          console.error('Error extracting commands:', error)
        }
        
        // Reset pending utterance
        pendingUtteranceRef.current = ""
        lastSpeechTimeRef.current = now + 999999 // Block until new speech
      }
    }, 500) // Check more frequently for better responsiveness
    
    return () => clearInterval(interval)
  }, [isRunning])

  const handlePolish = async (idx: number) => {
    const cmd = commands[idx]
    const contextWindow = transcript.slice(-1200)
    
    try {
      const result = await window.electronAPI.polishCommandResponse(cmd.command_text, {
        transcriptWindow: contextWindow,
        timestamp: cmd.timestamp,
        who: cmd.who_said_it
      })
      
      setCommands(prev => prev.map((c, i) => 
        i === idx ? { ...c, polished_response: result.text } : c
      ))
      setActiveTab('commands')
    } catch (error) {
      console.error('Error polishing response:', error)
    }
  }

  return (
    <Card className="card-floating border-border bg-card">
      <CardHeader className="pb-4 flex flex-row items-center justify-between">
        <div>
          <CardTitle className="text-base font-semibold text-foreground">
            Moonshine Live Transcription
          </CardTitle>
          <CardDescription className="text-xs text-muted-foreground">
            Fast, local speech recognition ‚Ä¢ {engineStatus}
          </CardDescription>
          {isRunning && (
            <div className="text-xs text-muted-foreground mt-1">
              Processed: {processingStats.chunksProcessed} chunks ‚Ä¢ 
              Avg latency: {processingStats.avgLatency.toFixed(1)}ms
            </div>
          )}
        </div>
        <div className="flex gap-2">
          <Button 
            variant={activeTab==='transcript'? 'default':'outline'} 
            size="sm" 
            onClick={() => setActiveTab('transcript')}
          >
            Transcript
          </Button>
          <Button 
            variant={activeTab==='commands'? 'default':'outline'} 
            size="sm" 
            onClick={() => setActiveTab('commands')}
          >
            Commands ({commands.length})
          </Button>
          {!isRunning ? (
            <Button size="sm" onClick={startCapture}>
              Start Moonshine
            </Button>
          ) : (
            <Button variant="outline" size="sm" onClick={stopCapture}>
              Stop
            </Button>
          )}
        </div>
      </CardHeader>
      <CardContent>
        {activeTab === 'transcript' ? (
          <div className="space-y-2">
            <div className="min-h-[160px] max-h-[280px] overflow-y-auto bg-secondary/30 rounded-lg p-3 border border-border">
              <p className="text-sm whitespace-pre-wrap leading-relaxed">
                {transcript || (isRunning ? 'Listening with Moonshine...' : 'Press Start to begin live transcription.')}
              </p>
            </div>
          </div>
        ) : (
          <div className="space-y-3">
            {commands.length === 0 && (
              <p className="text-xs text-muted-foreground">
                No commands detected yet. They will appear here in real time.
              </p>
            )}
            <div className="grid grid-cols-1 gap-2">
              {commands.map((cmd, idx) => (
                <div key={idx} className="card-premium p-3 animate-cmd-enter">
                  <div className="flex items-start justify-between">
                    <div>
                      <div className="text-sm font-semibold text-foreground">{cmd.command_text}</div>
                      <div className="text-xs text-muted-foreground mt-1">
                        {cmd.timestamp} ‚Ä¢ {cmd.who_said_it}
                      </div>
                      {cmd.polished_response && (
                        <div className="mt-2 p-2 bg-secondary/30 rounded-md p-2 border border-border">
                          <div className="text-xs text-muted-foreground mb-1">Response:</div>
                          <div className="text-sm whitespace-pre-wrap leading-relaxed">{cmd.polished_response}</div>
                        </div>
                      )}
                    </div>
                    <Button size="sm" onClick={() => handlePolish(idx)}>
                      Polish Response
                    </Button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  )
}

export default ImprovedLiveTranscriptPanel;

===== END FILE: src\components\Transcription\ImprovedLiveTranscriptPanel.tsx =====

===== BEGIN FILE: src\components\Transcription\LiveTranscriptPanel.tsx =====
import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../ui/card'
import { Button } from '../ui/button'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../ui/select'
import { Badge } from '../ui/badge'
import { Label } from '../ui/label'
import { encodeWavBase64 } from "../../lib/wav";

interface WordTs { word: string; start: number; end: number }
interface TranscriptResult { id: string; text: string; words?: WordTs[] }

interface ActionCommand {
  command_text: string
  timestamp: string
  who_said_it: string
  suggested_response: string
  polished_response?: string
}

// Simple deterministic string hash (djb2)
function hashString(str: string): string {
  let hash = 5381
  for (let i = 0; i < str.length; i++) {
    // hash * 33 + char
    hash = ((hash << 5) + hash) + str.charCodeAt(i)
    hash = hash & 0xffffffff
  }
  // Return as unsigned hex string for compactness
  return (hash >>> 0).toString(16)
}

// Normalize utterance to stabilize hashing and heuristics
function normalizeUtterance(s: string): string {
  return s
    .replace(/\s+/g, ' ')
    .replace(/[\u2018\u2019]/g, "'")
    .replace(/[\u201C\u201D]/g, '"')
    .trim()
}

// Extract the most recent, likely-complete sentence for faster, accurate extraction
function getExtractionCandidate(utterance: string): string {
  // Split by common sentence boundaries
  const parts = utterance.split(/([.!?])\s+/)
  if (parts.length <= 1) return utterance
  // Reconstruct into sentences: token + delimiter
  const sentences: string[] = []
  for (let i = 0; i < parts.length; i += 2) {
    const token = parts[i]
    const delim = parts[i + 1] || ''
    if (token && token.trim()) sentences.push((token + delim).trim())
  }
  // Prefer the last complete sentence; if last has no delimiter, try previous
  const last = sentences[sentences.length - 1] || ''
  if (/[.!?]$/.test(last)) return last
  return sentences[sentences.length - 2] || last || utterance
}

// Extract last N sentences to capture bursts (e.g., multiple questions back-to-back)
function getLastSentences(utterance: string, n: number = 2): string {
  const parts = utterance.split(/([.!?])\s+/)
  if (parts.length <= 1) return utterance
  const sentences: string[] = []
  for (let i = 0; i < parts.length; i += 2) {
    const token = parts[i]
    const delim = parts[i + 1] || ''
    if (token && token.trim()) sentences.push((token + delim).trim())
  }
  const start = Math.max(0, sentences.length - n)
  return sentences.slice(start).join(' ').trim()
}

const LiveTranscriptPanel: React.FC = () => {
  const [isRunning, setIsRunning] = useState(false)
  const [activeTab, setActiveTab] = useState<'transcript'|'commands'>('transcript')
  const [captureSource, setCaptureSource] = useState<'speaker'|'microphone'|'system'>('system')
  const [statusMsg, setStatusMsg] = useState<string>("")
  const [audioInputs, setAudioInputs] = useState<MediaDeviceInfo[]>([])
  const [selectedMicId, setSelectedMicId] = useState<string>("")
  
  // Transcription engine selection
  const [transcriptionEngine, setTranscriptionEngine] = useState<'whisper'|'deepgram'>('deepgram')
  
  // Deepgram configuration
  const [deepgramModel, setDeepgramModel] = useState<string>("nova-2")

  // Map Deepgram models to branded MindWhisper labels
  const brandModelLabel = (model: string): string => {
    switch ((model || '').toLowerCase()) {
      case 'nova-2': return 'Alpha'
      case 'nova': return 'Beta'
      case 'enhanced': return 'Gamma'
      case 'base': return 'Gamma'
      default: return model
    }
  }

  // Transform backend status strings to branded wording
  const brandStatus = (msg: string): string => {
    if (!msg) return ''
    let m = msg.replace(/deepgram/ig, 'MindWhisper')
    m = m
      .replace(/nova-2/ig, 'Alpha')
      .replace(/\bnova\b/ig, 'Beta')
      .replace(/enhanced/ig, 'Gamma')
      .replace(/\bbase\b/ig, 'Gamma')
    return m
  }

  // Transcript state
  const [transcript, setTranscript] = useState<string>("")
  const [history, setHistory] = useState<Array<{ text: string; start: number; end: number }>>([])
  const [commands, setCommands] = useState<any[]>([])
  const [searchQuery, setSearchQuery] = useState('')
  const [selectedCommandIndex, setSelectedCommandIndex] = useState(-1)

  // Streaming capture
  const mediaStreamRef = useRef<MediaStream|null>(null)
  const audioCtxRef = useRef<AudioContext|null>(null)
  const processorRef = useRef<ScriptProcessorNode|null>(null)
  const channelBuffersRef = useRef<Float32Array[]>([])
  const sampleRateRef = useRef<number>(48000)
  const framesCollectedRef = useRef<number>(0)
  const totalFramesSentRef = useRef<number>(0)
  const lastSpeechTimeRef = useRef<number>(Date.now())
  const currentSegmentStartRef = useRef<number>(0)
  const pendingUtteranceRef = useRef<string>("")
  const loopbackUnsubRef = useRef<(() => void) | null>(null)
  const deepgramUnsubRef = useRef<(() => void) | null>(null)

  // Deduplication stores
  const utteranceHashesRef = useRef<Set<string>>(new Set())
  const commandHashesRef = useRef<Set<string>>(new Set())

  // Concurrency and rate limiting
  const isExtractingRef = useRef<boolean>(false)
  const lastExtractTsRef = useRef<number>(0)
  const pendingRerunRef = useRef<boolean>(false)

  const capSet = (set: Set<string>, max = 200) => {
    if (set.size > max) {
      // Simple strategy: clear to avoid unbounded growth
      set.clear()
    }
  }

  // Unified extraction with deduplication
  const tryExtractCommands = useCallback(async (reason: string) => {
    if (isExtractingRef.current) {
      // Mark a pending rerun to coalesce with fresher text
      pendingRerunRef.current = true
      return
    }
    const now = Date.now()
    // Short cooldown to avoid bursts from streaming partials
    if (now - lastExtractTsRef.current < (transcriptionEngine === 'deepgram' ? 150 : 250)) {
      return
    }

    const raw = pendingUtteranceRef.current
    const utterance = normalizeUtterance(raw)
    if (!utterance) return

    // Engine-aware thresholds
    const minLen = transcriptionEngine === 'deepgram' ? 8 : 10
    if (utterance.length < minLen) return

    // Use last two sentences to batch multiple back-to-back questions/commands
    const candidate = getLastSentences(utterance, 2)
    const uhash = hashString(candidate)
    if (utteranceHashesRef.current.has(uhash)) {
      return
    }

    // Heuristic pre-filter to avoid unnecessary calls when clearly not a command
    const lowered = candidate.toLowerCase()
    const looksQuestion = /\?$/.test(candidate) || /\b(what|how|why|when|where|who|can|could|should|would)\b/.test(lowered)
    const hasCommandVerbs = /\b(send|email|summarize|schedule|remind|note|explain|clarify|list|create|generate|compare|draft|answer|translate|share|open|search|lookup|calculate|follow up|follow-up)\b/.test(lowered)
    const hasPoliteCue = /\b(please|can you|could you)\b/.test(lowered)
    const heuristicPass = looksQuestion || hasCommandVerbs || hasPoliteCue
    if (!heuristicPass) {
      return
    }

    try {
      // Debug hook for tracing extraction cause without noisy logs
      if (process.env.NODE_ENV !== 'production') {
        // eslint-disable-next-line no-console
        console.debug('[Command Extraction] Trigger:', reason, 'len=', candidate.length)
      }
      isExtractingRef.current = true
      const extracted = await window.electronAPI.extractCommands(candidate, new Date().toISOString())
      if (Array.isArray(extracted) && extracted.length > 0) {
        // Filter out duplicate commands by text
        const fresh = extracted.filter((cmd: any) => {
          const chash = hashString((cmd.command_text || '').toLowerCase())
          const isNew = !commandHashesRef.current.has(chash)
          if (isNew) {
            commandHashesRef.current.add(chash)
          }
          return isNew
        })

        if (fresh.length > 0) {
          // Backend now returns polished_response in a single call; prepend so latest appear on top
          setCommands(prev => [...fresh, ...prev])
          // Clear the pending utterance only when we successfully extracted commands
          pendingUtteranceRef.current = ""
        }
      }
      // Mark utterance as processed to avoid reprocessing
      utteranceHashesRef.current.add(uhash)
      capSet(utteranceHashesRef.current)
      capSet(commandHashesRef.current)
      lastExtractTsRef.current = now
    } catch (err) {
      // Swallow errors to keep stream robust
      console.error('[Command Extraction] Error:', err)
    } finally {
      isExtractingRef.current = false
      if (pendingRerunRef.current) {
        // Rerun immediately with freshest utterance, then clear flag
        pendingRerunRef.current = false
        setTimeout(() => tryExtractCommands('rerun'), 0)
      }
    }
  }, [transcriptionEngine])

  // Helpers
  const resetBuffers = () => {
    channelBuffersRef.current = []
    framesCollectedRef.current = 0
  }

  // Enumerate audio input devices (for microphone and Stereo Mix selection)
  useEffect(() => {
    navigator.mediaDevices.enumerateDevices().then(devices => {
      const inputs = devices.filter(d => d.kind === 'audioinput')
      setAudioInputs(inputs)
    }).catch(() => {})
  }, [])

  const handlePolish = async (idx: number) => {
    const cmd = commands[idx]
    if (!cmd) return
    try {
      const result = await window.electronAPI.polishCommandResponse(cmd.command_text, {
        transcriptWindow: transcript,
        timestamp: cmd.timestamp,
        who: cmd.who_said_it
      })
      setCommands(prev => prev.map((c, i) => i === idx ? { ...c, polished_response: result.text } : c))
    } catch (error) {
      console.error('Error polishing response:', error)
    }
  }

  const stopCapture = async () => {
    try {
      if (captureSource === 'system') {
        if (transcriptionEngine === 'deepgram') {
          await window.electronAPI.stopDeepgramTranscript()
          if (deepgramUnsubRef.current) {
            deepgramUnsubRef.current()
            deepgramUnsubRef.current = null
          }
        } else {
          await window.electronAPI.stopLoopbackTranscript()
          if (loopbackUnsubRef.current) {
            loopbackUnsubRef.current()
            loopbackUnsubRef.current = null
          }
        }
      } else {
        await window.electronAPI.stopLiveTranscript()
        if (processorRef.current) {
          processorRef.current.disconnect()
          processorRef.current = null
        }
        if (audioCtxRef.current) {
          audioCtxRef.current.close()
          audioCtxRef.current = null
        }
        if (mediaStreamRef.current) {
          mediaStreamRef.current.getTracks().forEach(track => track.stop())
          mediaStreamRef.current = null
        }
        resetBuffers()
        currentSegmentStartRef.current = 0
        lastSpeechTimeRef.current = Date.now()
        return
      }
    } catch (error) {
      console.error('Error stopping capture:', error)
      setStatusMsg(`Error stopping: ${error}`)
    }
    setIsRunning(false)
  }

  const startCapture = async () => {
    try {
      setStatusMsg("")
      let stream: MediaStream | null = null
      if (captureSource === 'system') {
        if (transcriptionEngine === 'deepgram') {
          // Deepgram transcription
          console.log('Starting Deepgram with:', { model: deepgramModel })
          
          const res = await window.electronAPI.startDeepgramTranscript({ 
            model: deepgramModel
          })
          if (!res?.success) throw new Error(res?.error || 'Failed to start Deepgram transcription')
          
          deepgramUnsubRef.current = window.electronAPI.onDeepgramTranscript((data) => {
            console.log('[Deepgram Frontend] Received transcript data:', data)
            const text = (data?.text || '').trim()
            if (text) {
              console.log('[Deepgram Frontend] Processing transcript:', text)
              setTranscript(prev => (prev ? prev + ' ' : '') + text)
              
              // Update pending utterance and timestamp
              const previousUtterance = pendingUtteranceRef.current
              pendingUtteranceRef.current = (pendingUtteranceRef.current ? pendingUtteranceRef.current + ' ' : '') + text
              lastSpeechTimeRef.current = Date.now()
              
              console.log('[Deepgram Frontend] Updated pendingUtterance:', {
                previous: previousUtterance,
                new: pendingUtteranceRef.current,
                length: pendingUtteranceRef.current.length,
                timestamp: lastSpeechTimeRef.current
              })
              
              // Force immediate command check for questions and commands
              const hasQuestion = /\?/.test(text)
              const hasCommand = /\b(can you|could you|please|explain|how do you|what are|how to)\b/i.test(text)
              
              if (hasQuestion || hasCommand) {
                // Faster immediate extraction to reduce perceived latency
                setTimeout(() => {
                  tryExtractCommands('immediate')
                }, 200)
              }
            } else {
              console.log('[Deepgram Frontend] Empty or invalid text received:', data)
            }
          })
          
          // Handle status messages
          const statusUnsub = window.electronAPI.onDeepgramStatus((message: string) => {
            console.log('Frontend received Deepgram status:', message)
            setStatusMsg(brandStatus(message))
          })
          
          // Handle ready notifications
          const readyUnsub = window.electronAPI.onDeepgramReady((data: any) => {
            console.log('Frontend received Deepgram ready:', data)
            setStatusMsg(`‚úÖ MindWhisper ${brandModelLabel(data.model)} ready`)
          })
          
          // Handle errors
          const errorUnsub = window.electronAPI.onDeepgramError((error: string) => {
            console.log('Frontend received Deepgram error:', error)
            setStatusMsg(`‚ùå MindWhisper Error: ${error}`)
            setIsRunning(false)
          })
          
          // Update cleanup to include new listeners
          const originalUnsub = deepgramUnsubRef.current
          deepgramUnsubRef.current = () => {
            originalUnsub?.()
            statusUnsub?.()
            readyUnsub?.()
            errorUnsub?.()
          }
          setIsRunning(true)
          setStatusMsg(`Starting MindWhisper ${brandModelLabel(deepgramModel)} transcription...`)
          return
        } else {
          // Whisper transcription (existing code)
          console.log('Starting loopback with:', { model: 'medium', engine: 'openai' })
          const res = await window.electronAPI.startLoopbackTranscript({ 
            model: 'medium', 
            engine: 'openai' 
          })
          if (!res?.success) throw new Error(res?.error || 'Failed to start loopback transcription')
          loopbackUnsubRef.current = window.electronAPI.onLoopbackTranscript((data) => {
            const text = (data?.text || '').trim()
            if (text) {
              setTranscript(prev => (prev ? prev + ' ' : '') + text)
              pendingUtteranceRef.current = (pendingUtteranceRef.current ? pendingUtteranceRef.current + ' ' : '') + text
              lastSpeechTimeRef.current = Date.now()
            }
          })
          
          // Handle status messages - CRITICAL: Remove optional chaining
          const statusUnsub = window.electronAPI.onLoopbackStatus((message: string) => {
            console.log('Frontend received status:', message)
            setStatusMsg(message)
          })
          
          // Handle fallback notifications
          const fallbackUnsub = window.electronAPI.onLoopbackFallback((data: any) => {
            console.log('Frontend received fallback:', data)
            setStatusMsg(`‚ö†Ô∏è ${data.message} - Using ${data.fallbackModel} instead`)
          })
          
          // Handle errors
          const errorUnsub = window.electronAPI.onLoopbackError((error: string) => {
            console.log('Frontend received error:', error)
            setStatusMsg(`‚ùå Error: ${error}`)
            setIsRunning(false)
          })
          
          // Update cleanup to include new listeners
          const originalUnsub = loopbackUnsubRef.current
          loopbackUnsubRef.current = () => {
            originalUnsub?.()
            statusUnsub?.()
            fallbackUnsub?.()
            errorUnsub?.()
          }
          setIsRunning(true)
          setStatusMsg(`Started native system audio capture with Whisper medium`)
          return
        }
      } else if (captureSource === 'speaker') {
        // If the user selected a loopback-like device, prefer using it directly
        const selectedDevice = audioInputs.find(d => d.deviceId === selectedMicId)
        const looksLikeLoopback = selectedDevice && /stereo mix|loopback|what u hear|vb\-audio|cable output|wave out/i.test(selectedDevice.label || '')
        
        if (looksLikeLoopback) {
          stream = await navigator.mediaDevices.getUserMedia({
            audio: { deviceId: selectedMicId ? { exact: selectedMicId } : undefined }
          })
        } else {
          // Fallback: try to get display media with audio
          try {
            stream = await navigator.mediaDevices.getDisplayMedia({ 
              video: false, 
              audio: true 
            })
          } catch (displayError) {
            // If display media fails, try getUserMedia with default device
            stream = await navigator.mediaDevices.getUserMedia({
              audio: { deviceId: selectedMicId ? { exact: selectedMicId } : undefined }
            })
          }
        }
      } else {
        // Microphone
        stream = await navigator.mediaDevices.getUserMedia({
          audio: { deviceId: selectedMicId ? { exact: selectedMicId } : undefined }
        })
      }

      if (!stream) throw new Error('Failed to get media stream')
      
      mediaStreamRef.current = stream
      const audioCtx = new AudioContext({ sampleRate: 48000 })
      audioCtxRef.current = audioCtx
      sampleRateRef.current = audioCtx.sampleRate

      const source = audioCtx.createMediaStreamSource(stream)
      const processor = audioCtx.createScriptProcessor(4096, 1, 1)
      processorRef.current = processor

      processor.onaudioprocess = (e) => {
        const inputBuffer = e.inputBuffer
        const inputData = inputBuffer.getChannelData(0)
        
        // Collect frames
        if (!channelBuffersRef.current.length) {
          channelBuffersRef.current = [new Float32Array(inputData)]
        } else {
          const newBuffer = new Float32Array(channelBuffersRef.current[0].length + inputData.length)
          newBuffer.set(channelBuffersRef.current[0])
          newBuffer.set(inputData, channelBuffersRef.current[0].length)
          channelBuffersRef.current = [newBuffer]
        }
        
        framesCollectedRef.current += inputData.length

        // Send chunks every ~1 second
        const targetFrames = Math.floor(sampleRateRef.current * 1.0)
        if (framesCollectedRef.current >= targetFrames) {
          const audioData = channelBuffersRef.current[0].slice(0, targetFrames)
          const base64Wav = encodeWavBase64([audioData], sampleRateRef.current)
          const chunkId = `chunk_${totalFramesSentRef.current}`
          
          window.electronAPI.sendTranscriptChunk(chunkId, base64Wav).then(result => {
            const text = (result?.text || '').trim()
            if (text) {
              setTranscript(prev => (prev ? prev + ' ' : '') + text)
              pendingUtteranceRef.current = (pendingUtteranceRef.current ? pendingUtteranceRef.current + ' ' : '') + text
              lastSpeechTimeRef.current = Date.now()
            }
          }).catch(console.error)

          // Shift buffer
          const remaining = channelBuffersRef.current[0].slice(targetFrames)
          channelBuffersRef.current = [remaining]
          framesCollectedRef.current = remaining.length
          totalFramesSentRef.current++
        }
      }

      source.connect(processor)
      processor.connect(audioCtx.destination)

      // Start live transcript backend
      const res = await window.electronAPI.startLiveTranscript()
      if (!res?.success) throw new Error(res?.error || 'Failed to start live transcript')

      setIsRunning(true)
      setStatusMsg(`Capturing from ${captureSource}...`)
    } catch (error) {
      console.error('Error starting capture:', error)
      setStatusMsg(`Error: ${error}`)
      setIsRunning(false)
    }
  }

  // Command extraction from accumulated utterances
  useEffect(() => {
    console.log('[Command Extraction] useEffect triggered, pendingUtterance:', pendingUtteranceRef.current)
    if (!pendingUtteranceRef.current) {
      console.log('[Command Extraction] No pending utterance, skipping')
      return
    }
    
    const checkForCommands = async () => {
      const now = Date.now()
      const timeSinceLastSpeech = now - lastSpeechTimeRef.current
      const utterance = pendingUtteranceRef.current.trim()
      
      console.log('[Command Check] Current state:', {
        transcriptionEngine,
        utterance: utterance.substring(0, 50) + '...',
        utteranceLength: utterance.length,
        timeSinceLastSpeech,
        lastSpeechTime: lastSpeechTimeRef.current,
        now
      })
      
      // Different thresholds for different transcription engines
      let silenceThreshold = 3000 // Default 3 seconds for Whisper
      let minUtteranceLength = 10 // Minimum characters for processing
      let checkInterval = 500 // Default check interval
      
      if (transcriptionEngine === 'deepgram') {
        // Deepgram streams in real-time, so use much shorter thresholds
        silenceThreshold = 800 // 1200 for Deepgram (much more responsive)
        minUtteranceLength = 8 // Lower minimum for real-time processing
        checkInterval = 200 // Check more frequently for Deepgram
      }
      
      console.log('[Command Check] Thresholds:', { silenceThreshold, minUtteranceLength, checkInterval })
      
      // Enhanced sentence boundary detection for Deepgram
      let shouldProcess = false
      let processingReason = ""
      
      if (transcriptionEngine === 'deepgram') {
        // Multiple triggers for Deepgram processing
        const hasSentenceEnding = /[.!?]\s*$/.test(utterance) || 
                                 /[.!?]\s+/.test(utterance) ||
                                 utterance.includes('. ') || 
                                 utterance.includes('! ') || 
                                 utterance.includes('? ')
        
        const hasCommandKeywords = /\b(can you|could you|please|action|task|todo|remind|schedule|send|email|call|meeting|follow up|note|write|create|update|delete|add|remove)\b/i.test(utterance)
        
        const hasQuestionPattern = /\b(what|when|where|who|why|how|is|are|do|does|did|will|would|should|could)\b.*\?/i.test(utterance)
        
        const isLongEnough = utterance.length >= minUtteranceLength
        const hasRecentSilence = timeSinceLastSpeech > silenceThreshold
        
        // Process if any of these conditions are met
        if (isLongEnough && (
          (hasSentenceEnding && timeSinceLastSpeech > 400) || // Quick processing for sentence endings
          (hasCommandKeywords && timeSinceLastSpeech > 600) || // Command keywords with short silence
          (hasQuestionPattern && timeSinceLastSpeech > 500) || // Questions with short silence
          (hasRecentSilence && utterance.length >= 15) // Longer utterances with normal silence
        )) {
          shouldProcess = true
          processingReason = `sentence:${hasSentenceEnding}, keywords:${hasCommandKeywords}, question:${hasQuestionPattern}, silence:${hasRecentSilence}`
        }
      } else {
        // Original Whisper logic
        shouldProcess = timeSinceLastSpeech > silenceThreshold && utterance.length >= minUtteranceLength
        processingReason = "whisper-standard"
      }
      
      if (shouldProcess) {
        await tryExtractCommands(`interval:${processingReason}`)
      }
      
      // Cleanup old utterances to prevent memory buildup
      if (transcriptionEngine === 'deepgram' && timeSinceLastSpeech > 5000) {
        console.log('[Deepgram] Cleaning up old utterance due to extended silence')
        pendingUtteranceRef.current = ""
      } else if (transcriptionEngine === 'whisper' && timeSinceLastSpeech > 10000) {
        console.log('[Whisper] Cleaning up old utterance due to extended silence')
        pendingUtteranceRef.current = ""
      }
    }

    // Use different intervals based on transcription engine
    const interval = transcriptionEngine === 'deepgram' ? 200 : 500
    const checkInterval = setInterval(checkForCommands, interval)
    return () => clearInterval(checkInterval)
  }, [transcriptionEngine, tryExtractCommands]) // Add unified extractor as dependency

  // Filter commands based on search
  const filteredCommands = useMemo(() => {
    if (!searchQuery) return commands
    return commands.filter(cmd => 
      cmd.command_text.toLowerCase().includes(searchQuery.toLowerCase()) ||
      (cmd.polished_response && cmd.polished_response.toLowerCase().includes(searchQuery.toLowerCase()))
    )
  }, [commands, searchQuery])

  // Keyboard shortcuts handler
  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    if (e.ctrlKey || e.metaKey) {
      switch (e.key) {
        case 'k':
          e.preventDefault()
          document.getElementById('command-search')?.focus()
          break
        case 'c':
          if (activeTab === 'transcript' && transcript) {
            e.preventDefault()
            navigator.clipboard.writeText(transcript)
          } else if (activeTab === 'commands' && filteredCommands.length > 0) {
            e.preventDefault()
            const allText = filteredCommands.map(cmd => 
              `${cmd.command_text}${cmd.polished_response ? '\n' + cmd.polished_response : ''}`
            ).join('\n\n')
            navigator.clipboard.writeText(allText)
          }
          break
        case 'Enter':
          if (selectedCommandIndex >= 0 && selectedCommandIndex < filteredCommands.length) {
            e.preventDefault()
            handlePolish(commands.indexOf(filteredCommands[selectedCommandIndex]))
          }
          break
      }
    } else {
      switch (e.key) {
        case 'ArrowDown':
          if (activeTab === 'commands' && filteredCommands.length > 0) {
            e.preventDefault()
            setSelectedCommandIndex(prev => 
              prev < filteredCommands.length - 1 ? prev + 1 : 0
            )
          }
          break
        case 'ArrowUp':
          if (activeTab === 'commands' && filteredCommands.length > 0) {
            e.preventDefault()
            setSelectedCommandIndex(prev => 
              prev > 0 ? prev - 1 : filteredCommands.length - 1
            )
          }
          break
        case 'Escape':
          setSearchQuery('')
          setSelectedCommandIndex(-1)
          break
      }
    }
  }, [activeTab, transcript, filteredCommands, selectedCommandIndex, commands])

  // Add keyboard event listeners
  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown)
    return () => document.removeEventListener('keydown', handleKeyDown)
  }, [handleKeyDown])

  // Reset selection when switching tabs or filtering
  useEffect(() => {
    setSelectedCommandIndex(-1)
  }, [activeTab, searchQuery])

  // Auto-scroll transcript
  const transcriptDisplayText = useMemo(() => {
    if (!transcript) return isRunning ? 'Listening‚Ä¶' : 'Press Start to begin live transcription.'
    return transcript
  }, [transcript, isRunning])

  return (
    <Card className="card-floating">
      <CardHeader>
        <div className="flex flex-col gap-3">
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="text-lg font-semibold">Live Transcription</CardTitle>
              <CardDescription className="text-sm text-muted-foreground">
                Real-time speech-to-text with command extraction
              </CardDescription>
            </div>
            {statusMsg && (
              <div className="text-xs text-muted-foreground bg-secondary/30 border border-border px-2 py-1 rounded-md backdrop-blur-sm">
                {statusMsg}
              </div>
            )}
          </div>
          
          <div className="flex gap-2 items-center flex-wrap">
            <div className="flex gap-2 items-center mr-2">
              <span className="text-xs text-muted-foreground">Source</span>
              <Button variant="default" size="sm" disabled className="cursor-default">
                Speaker (Native)
              </Button>
            </div>
            
            {/* Transcription Engine Selection for Native Speaker mode */}
            {captureSource === 'system' && (
              <div className="flex gap-1 items-center mr-2">
                {/* MindWhisper is the default engine for Native Speaker mode */}
              </div>
            )}
            
            {/* Model Selection for Native Speaker mode */}
            {captureSource === 'system' && transcriptionEngine === 'whisper' && (
              <div className="flex items-center gap-2">
                {/* MindWhisper only mode: Whisper model selection removed */}
              </div>
            )}
            
            {/* Deepgram Configuration for Native Speaker mode */}
            {captureSource === 'system' && transcriptionEngine === 'deepgram' && (
              <>
                <div className="flex items-center gap-3 flex-1 min-w-0">
                  <Label className="text-xs text-muted-foreground whitespace-nowrap font-medium">MindWhisper Model</Label>
                  <Select value={deepgramModel} onValueChange={setDeepgramModel}>
                    <SelectTrigger className="h-8 text-xs hover:-translate-y-0.5 transition-all duration-200">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="nova-2">
                        <div className="flex items-center gap-2">
                          <Badge variant="success" className="text-[10px] px-1.5 py-0.5">Latest</Badge>
                          <span>Alpha</span>
                        </div>
                      </SelectItem>
                      <SelectItem value="nova">
                        <div className="flex items-center gap-2">
                          <div className="w-2 h-2 rounded-full bg-blue-400"></div>
                          <span>Beta</span>
                        </div>
                      </SelectItem>
                      <SelectItem value="enhanced">
                        <div className="flex items-center gap-2">
                          <div className="w-2 h-2 rounded-full bg-amber-400"></div>
                          <span>Gamma</span>
                        </div>
                      </SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </>
            )}
            
            {/* Device selection and refresh removed to simplify UI for Native Speaker mode */}
          </div>
          
          <div className="flex gap-3 items-center flex-wrap">
            <div className="flex gap-1 bg-stealth-card/30 p-1 rounded-lg border border-stealth-border/50">
              <Button 
                variant={activeTab==='transcript'? 'default':'ghost'} 
                size="sm" 
                className="h-8 px-3 text-xs hover:-translate-y-0.5 transition-all duration-200 data-[state=active]:shadow-stealth-sm" 
                onClick={() => setActiveTab('transcript')}
              >
                <svg className="w-3 h-3 mr-1.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
                Transcript
              </Button>
              <Button 
                variant={activeTab==='commands'? 'default':'ghost'} 
                size="sm" 
                className="h-8 px-3 text-xs hover:-translate-y-0.5 transition-all duration-200 data-[state=active]:shadow-stealth-sm" 
                onClick={() => setActiveTab('commands')}
              >
                <svg className="w-3 h-3 mr-1.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4" />
                </svg>
                Commands
              </Button>
            </div>
            
            {!isRunning ? (
              <Button
                variant="default"
                size="sm"
                onClick={startCapture}
                className="live-mode-btn live-mode-breathing hover-lift spring-bounce h-9 px-4 font-medium group"
              >
                <div className="flex items-center gap-2">
                  <div className="w-2 h-2 bg-emerald-400 rounded-full animate-pulse group-hover:animate-none"></div>
                  <span>Start Live Transcript</span>
                </div>
              </Button>
            ) : (
              <Button 
                variant="outline" 
                size="sm" 
                className="h-9 px-4 hover:-translate-y-0.5 transition-all duration-200 group" 
                onClick={stopCapture}
              >
                <div className="flex items-center gap-2">
                  <div className="w-2 h-2 bg-red-400 rounded-full animate-pulse"></div>
                  <span>Stop Recording</span>
                </div>
              </Button>
            )}
          </div>
        </div>
      </CardHeader>
      
      <CardContent>
        {activeTab === 'transcript' ? (
          <div className="space-y-2">
            {/* Transcript Header with Actions */}
            <div className="flex items-center justify-between">
              <div className="text-xs text-muted-foreground">
                {transcript ? `${transcript.split(' ').length} words transcribed` : 'Ready to transcribe'}
              </div>
              {transcript && (
                <Button 
                  variant="ghost" 
                  size="sm" 
                  onClick={() => navigator.clipboard.writeText(transcript)}
                  className="h-7 px-2 text-xs"
                >
                  Copy Transcript
                </Button>
              )}
            </div>
            
            {/* Enhanced Transcript Display */}
            <div className="min-h-[160px] max-h-[280px] overflow-y-auto card-premium p-3 relative">
              <div className="text-sm leading-relaxed">
                {transcript ? (
                  <div className="whitespace-pre-wrap">
                    {transcript.split(/([.!?]+)/).map((part, idx) => {
                      if (/[.!?]+/.test(part)) {
                        return <span key={idx} className="text-foreground font-medium">{part}</span>
                      }
                      return <span key={idx} className="text-foreground">{part}</span>
                    })}
                  </div>
                ) : (
                  <div className="text-muted-foreground italic">
                    {isRunning ? (
                      <div className="flex items-center gap-2">
                        <div className="w-2 h-2 bg-foreground rounded-full animate-pulse"></div>
                        Listening for speech...
                      </div>
                    ) : (
                      'Press Start to begin live transcription'
                    )}
                  </div>
                )}
              </div>
            </div>
          </div>
        ) : (
          <div className="space-y-3">
            {/* Commands Header with Search and Actions */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <div className="text-xs text-muted-foreground">
                  {commands.length === 0 ? 'No commands detected yet' : 
                   `${filteredCommands.length}${searchQuery ? ` of ${commands.length}` : ''} command${filteredCommands.length === 1 ? '' : 's'}`}
                </div>
                {commands.length > 0 && (
                  <div className="flex gap-2">
                    <Button 
                      variant="ghost" 
                      size="sm" 
                      onClick={() => {
                        const allText = filteredCommands.filter(cmd => cmd.polished_response).map(cmd => 
                          `${cmd.command_text}\n${cmd.polished_response}`
                        ).join('\n\n')
                        navigator.clipboard.writeText(allText)
                      }}
                      className="h-7 px-2 text-xs"
                      title="Ctrl+C"
                    >
                      Copy All
                    </Button>
                    <Button 
                      variant="ghost" 
                      size="sm" 
                      onClick={() => setCommands([])}
                      className="h-7 px-2 text-xs"
                    >
                      Clear
                    </Button>
                  </div>
                )}
              </div>
              
              {/* Search Input */}
              {commands.length > 0 && (
                <div className="relative">
                  <input
                    id="command-search"
                    type="text"
                    placeholder="Search commands... (Ctrl+K)"
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    className="w-full h-8 px-3 text-xs bg-secondary/20 border border-border/50 rounded focus:outline-none focus:ring-1 focus:ring-foreground/20 focus:border-foreground/30"
                  />
                  {searchQuery && (
                    <button
                      onClick={() => setSearchQuery('')}
                      className="absolute right-2 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground text-xs"
                    >
                      ‚úï
                    </button>
                  )}
                </div>
              )}
            </div>
            
            {/* Scrollable Commands Container */}
            <div className="max-h-[320px] overflow-y-auto space-y-2 pr-2">
              {filteredCommands.length === 0 && searchQuery ? (
                <div className="text-center py-8 text-muted-foreground text-sm">
                  No commands match "{searchQuery}"
                </div>
              ) : (
                filteredCommands.map((cmd, idx) => {
                  const originalIndex = commands.indexOf(cmd)
                  const isSelected = idx === selectedCommandIndex
                  return (
                    <div 
                      key={originalIndex} 
                      className={`bg-card border rounded-lg p-3 transition-all duration-150 hover:shadow-sm animate-cmd-enter ${
                        isSelected ? 'border-foreground/30 bg-secondary/30' : 'border-border'
                      }`}
                    >
                  {/* Command Header */}
                  <div className="flex items-start justify-between gap-3">
                    <div className="flex-1 min-w-0">
                      <div className="text-sm font-medium text-foreground leading-tight">{cmd.command_text}</div>
                      <div className="text-xs text-muted-foreground mt-1 flex items-center gap-2">
                        <span>{cmd.timestamp}</span>
                        <span>‚Ä¢</span>
                        <span>{cmd.who_said_it}</span>
                      </div>
                    </div>
                    <div className="flex gap-1 flex-shrink-0">
                      <Button 
                        variant="ghost" 
                        size="sm" 
                        onClick={() => {
                          const text = `${cmd.command_text}${cmd.polished_response ? '\n' + cmd.polished_response : ''}`
                          navigator.clipboard.writeText(text)
                        }}
                        className="h-7 w-7 p-0 text-xs"
                        title="Copy command"
                      >
                        ‚ßâ
                      </Button>
                      <Button 
                        variant="outline" 
                        size="sm" 
                        onClick={() => handlePolish(originalIndex)}
                        className="h-7 px-2 text-xs"
                        title={isSelected ? "Enter to polish" : ""}
                      >
                        Polish
                      </Button>
                    </div>
                  </div>
                  
                  {/* Polished Response */}
                  {cmd.polished_response && (
                    <div className="mt-2 p-2 bg-foreground/5 rounded border border-foreground/10">
                      <div className="text-xs text-muted-foreground mb-1">Response:</div>
                      <div className="text-sm text-foreground leading-relaxed whitespace-pre-wrap">{cmd.polished_response}</div>
                    </div>
                  )}
                    </div>
                  )
                })
              )}
            </div>
            
            {/* Keyboard Shortcuts Help */}
            {commands.length > 0 && (
              <div className="text-xs text-muted-foreground border-t border-border/30 pt-2 mt-2">
                <div className="flex gap-4 text-[10px]">
                  <span><kbd className="px-1 bg-secondary/50 rounded text-[9px]">Ctrl+K</kbd> Search</span>
                  <span><kbd className="px-1 bg-secondary/50 rounded text-[9px]">Ctrl+C</kbd> Copy</span>
                  <span><kbd className="px-1 bg-secondary/50 rounded text-[9px]">‚Üë‚Üì</kbd> Navigate</span>
                  <span><kbd className="px-1 bg-secondary/50 rounded text-[9px]">Enter</kbd> Polish</span>
                </div>
              </div>
            )}
          </div>
        )}
      </CardContent>
    </Card>
  )
}

export default LiveTranscriptPanel;

===== END FILE: src\components\Transcription\LiveTranscriptPanel.tsx =====

===== BEGIN FILE: src\components\Transcription\LiveTranscriptPanel_backup.tsx =====
import React, { useEffect, useMemo, useRef, useState } from "react";
import { Button } from "../ui/button";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "../ui/card";
import { encodeWavBase64 } from "../../lib/wav";

interface WordTs { word: string; start: number; end: number }
interface TranscriptResult { id: string; text: string; words?: WordTs[] }

interface ActionCommand {
  command_text: string
  timestamp: string
  who_said_it: string
  suggested_response: string
  polished_response?: string
}

const LiveTranscriptPanel: React.FC = () => {
  const [isRunning, setIsRunning] = useState(false)
  const [activeTab, setActiveTab] = useState<'transcript'|'commands'>('transcript')
  const [captureSource, setCaptureSource] = useState<'speaker'|'microphone'|'system'>('speaker')
  const [statusMsg, setStatusMsg] = useState<string>("")
  const [audioInputs, setAudioInputs] = useState<MediaDeviceInfo[]>([])
  const [selectedMicId, setSelectedMicId] = useState<string>("")
  
  // Whisper model selection
  const [whisperModel, setWhisperModel] = useState<string>("large-v3")
  const [whisperEngine, setWhisperEngine] = useState<string>("openai")

  // Transcript state
  const [transcript, setTranscript] = useState<string>("")
  const [history, setHistory] = useState<Array<{ text: string; start: number; end: number }>>([])
  const [commands, setCommands] = useState<ActionCommand[]>([])

  // Streaming capture
  const mediaStreamRef = useRef<MediaStream|null>(null)
  const audioCtxRef = useRef<AudioContext|null>(null)
  const processorRef = useRef<ScriptProcessorNode|null>(null)
  const channelBuffersRef = useRef<Float32Array[]>([])
  const sampleRateRef = useRef<number>(48000)
  const framesCollectedRef = useRef<number>(0)
  const totalFramesSentRef = useRef<number>(0)
  const lastSpeechTimeRef = useRef<number>(Date.now())
  const currentSegmentStartRef = useRef<number>(0)
  const pendingUtteranceRef = useRef<string>("")
  const loopbackUnsubRef = useRef<(() => void) | null>(null)

  // Helpers
  const resetBuffers = () => {
    channelBuffersRef.current = []
    framesCollectedRef.current = 0
  }

  // Enumerate audio input devices (for microphone and Stereo Mix selection)
  useEffect(() => {
    navigator.mediaDevices.enumerateDevices().then(devices => {
      const inputs = devices.filter(d => d.kind === 'audioinput')
      setAudioInputs(inputs)
    }).catch(() => {})
  }, [])

  const handlePolish = async (idx: number) => {
    const cmd = commands[idx]
    if (!cmd) return
    try {
      const result = await window.electronAPI.polishCommandResponse(cmd.command_text, {
        transcriptWindow: transcript,
        timestamp: cmd.timestamp,
        who: cmd.who_said_it
      })
      setCommands(prev => prev.map((c, i) => i === idx ? { ...c, polished_response: result.text } : c))
    } catch (error) {
      console.error('Error polishing response:', error)
    }
  }

  const stopCapture = async () => {
    try {
      if (captureSource === 'system') {
        await window.electronAPI.stopLoopbackTranscript()
        if (loopbackUnsubRef.current) {
          loopbackUnsubRef.current()
          loopbackUnsubRef.current = null
        }
      } else {
        await window.electronAPI.stopLiveTranscript()
        if (processorRef.current) {
          processorRef.current.disconnect()
          processorRef.current = null
        }
        if (audioCtxRef.current) {
          audioCtxRef.current.close()
          audioCtxRef.current = null
        }
        if (mediaStreamRef.current) {
          mediaStreamRef.current.getTracks().forEach(track => track.stop())
          mediaStreamRef.current = null
        }
        resetBuffers()
        currentSegmentStartRef.current = 0
        lastSpeechTimeRef.current = Date.now()
        return
      }
    } catch (error) {
      console.error('Error stopping capture:', error)
      setStatusMsg(`Error stopping: ${error}`)
    }
    setIsRunning(false)
  }

  const startCapture = async () => {
    try {
      setStatusMsg("")
      let stream: MediaStream | null = null
      if (captureSource === 'system') {
        // Native loopback path handled entirely in backend; set up event listener
        const res = await window.electronAPI.startLoopbackTranscript({ 
          model: whisperModel, 
          engine: whisperEngine 
        })
        if (!res?.success) throw new Error(res?.error || 'Failed to start loopback transcription')
        loopbackUnsubRef.current = window.electronAPI.onLoopbackTranscript((data) => {
          const text = (data?.text || '').trim()
          if (text) {
            setTranscript(prev => (prev ? prev + ' ' : '') + text)
            pendingUtteranceRef.current = (pendingUtteranceRef.current ? pendingUtteranceRef.current + ' ' : '') + text
            lastSpeechTimeRef.current = Date.now()
          }
        })
        setIsRunning(true)
        setStatusMsg(`Started native system audio capture with ${whisperEngine} Whisper ${whisperModel}`)
        return
      } else if (captureSource === 'speaker') {
        // If the user selected a loopback-like device, prefer using it directly
        const selectedDevice = audioInputs.find(d => d.deviceId === selectedMicId)
        const looksLikeLoopback = selectedDevice && /stereo mix|loopback|what u hear|vb\-audio|cable output|wave out/i.test(selectedDevice.label || '')
        
        if (looksLikeLoopback) {
          stream = await navigator.mediaDevices.getUserMedia({
            audio: { deviceId: selectedMicId ? { exact: selectedMicId } : undefined }
          })
        } else {
          // Fallback: try to get display media with audio
          try {
            stream = await navigator.mediaDevices.getDisplayMedia({ 
              video: false, 
              audio: true 
            })
          } catch (displayError) {
            // If display media fails, try getUserMedia with default device
            stream = await navigator.mediaDevices.getUserMedia({
              audio: { deviceId: selectedMicId ? { exact: selectedMicId } : undefined }
            })
          }
        }
      } else {
        // Microphone
        stream = await navigator.mediaDevices.getUserMedia({
          audio: { deviceId: selectedMicId ? { exact: selectedMicId } : undefined }
        })
      }

      if (!stream) throw new Error('Failed to get media stream')
      
      mediaStreamRef.current = stream
      const audioCtx = new AudioContext({ sampleRate: 48000 })
      audioCtxRef.current = audioCtx
      sampleRateRef.current = audioCtx.sampleRate

      const source = audioCtx.createMediaStreamSource(stream)
      const processor = audioCtx.createScriptProcessor(4096, 1, 1)
      processorRef.current = processor

      processor.onaudioprocess = (e) => {
        const inputBuffer = e.inputBuffer
        const inputData = inputBuffer.getChannelData(0)
        
        // Collect frames
        if (!channelBuffersRef.current.length) {
          channelBuffersRef.current = [new Float32Array(inputData)]
        } else {
          const newBuffer = new Float32Array(channelBuffersRef.current[0].length + inputData.length)
          newBuffer.set(channelBuffersRef.current[0])
          newBuffer.set(inputData, channelBuffersRef.current[0].length)
          channelBuffersRef.current = [newBuffer]
        }
        
        framesCollectedRef.current += inputData.length

        // Send chunks every ~1 second
        const targetFrames = Math.floor(sampleRateRef.current * 1.0)
        if (framesCollectedRef.current >= targetFrames) {
          const audioData = channelBuffersRef.current[0].slice(0, targetFrames)
          const base64Wav = encodeWavBase64([audioData], sampleRateRef.current)
          const chunkId = `chunk_${totalFramesSentRef.current}`
          
          window.electronAPI.sendTranscriptChunk(chunkId, base64Wav).then(result => {
            const text = (result?.text || '').trim()
            if (text) {
              setTranscript(prev => (prev ? prev + ' ' : '') + text)
              pendingUtteranceRef.current = (pendingUtteranceRef.current ? pendingUtteranceRef.current + ' ' : '') + text
              lastSpeechTimeRef.current = Date.now()
            }
          }).catch(console.error)

          // Shift buffer
          const remaining = channelBuffersRef.current[0].slice(targetFrames)
          channelBuffersRef.current = [remaining]
          framesCollectedRef.current = remaining.length
          totalFramesSentRef.current++
        }
      }

      source.connect(processor)
      processor.connect(audioCtx.destination)

      // Start live transcript backend
      const res = await window.electronAPI.startLiveTranscript()
      if (!res?.success) throw new Error(res?.error || 'Failed to start live transcript')

      setIsRunning(true)
      setStatusMsg(`Capturing from ${captureSource}...`)
    } catch (error) {
      console.error('Error starting capture:', error)
      setStatusMsg(`Error: ${error}`)
      setIsRunning(false)
    }
  }

  // Command extraction from accumulated utterances
  useEffect(() => {
    if (!pendingUtteranceRef.current) return
    
    const checkForCommands = async () => {
      const now = Date.now()
      const timeSinceLastSpeech = now - lastSpeechTimeRef.current
      
      // If 3 seconds of silence, process the accumulated utterance
      if (timeSinceLastSpeech > 3000 && pendingUtteranceRef.current.trim()) {
        try {
          const utterance = pendingUtteranceRef.current.trim()
          const extractedCommands = await window.electronAPI.extractCommands(utterance, new Date().toISOString())
          
          if (extractedCommands && extractedCommands.length > 0) {
            setCommands(prev => [...prev, ...extractedCommands])
          }
          
          // Clear the pending utterance
          pendingUtteranceRef.current = ""
        } catch (error) {
          console.error('Error extracting commands:', error)
        }
      }
    }

    const interval = setInterval(checkForCommands, 1000)
    return () => clearInterval(interval)
  }, [])

  // Auto-scroll transcript
  const transcriptDisplayText = useMemo(() => {
    if (!transcript) return isRunning ? 'Listening‚Ä¶' : 'Press Start to begin live transcription.'
    return transcript
  }, [transcript, isRunning])

  return (
    <Card className="card-premium">
      <CardHeader>
        <div className="flex flex-col gap-3">
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="text-lg font-semibold">Live Transcription</CardTitle>
              <CardDescription className="text-sm text-muted-foreground">
                Real-time speech-to-text with command extraction
              </CardDescription>
            </div>
            {statusMsg && (
              <div className="text-xs text-muted-foreground bg-secondary/50 px-2 py-1 rounded">
                {statusMsg}
              </div>
            )}
          </div>
          
          <div className="flex gap-2 items-center flex-wrap">
            <div className="flex gap-1 items-center mr-2">
              <Button variant={captureSource==='speaker'? 'default':'outline'} size="sm" onClick={() => setCaptureSource('speaker')}>Speaker</Button>
              <Button variant={captureSource==='microphone'? 'default':'outline'} size="sm" onClick={() => setCaptureSource('microphone')}>Mic</Button>
              <Button variant={captureSource==='system'? 'default':'outline'} size="sm" onClick={() => setCaptureSource('system')}>Speaker (Native)</Button>
            </div>
            
            {/* Device selector (microphones, including Stereo Mix) */}
            <div className="flex items-center gap-2">
              <label className="text-xs text-muted-foreground">Device</label>
              <select
                className="input-premium h-8 w-56 text-xs"
                value={selectedMicId}
                onChange={(e) => setSelectedMicId(e.target.value)}
              >
                <option value="">System Default</option>
                {audioInputs.map((d) => (
                  <option key={d.deviceId} value={d.deviceId}>{d.label || 'Microphone'}</option>
                ))}
              </select>
            </div>
            
            {/* Whisper Model Selection for Native Speaker mode */}
            {captureSource === 'system' && (
              <div className="flex items-center gap-2">
                <label className="text-xs text-muted-foreground">Model</label>
                <select
                  className="input-premium h-8 w-40 text-xs"
                  value={`${whisperEngine}-${whisperModel}`}
                  onChange={(e) => {
                    const [engine, model] = e.target.value.split('-', 2)
                    setWhisperEngine(engine)
                    setWhisperModel(model)
                  }}
                >
                  <option value="openai-large-v3">Whisper Large-v3</option>
                  <option value="faster-large-v3">Faster Whisper Large-v3</option>
                  <option value="openai-base">Whisper Base</option>
                  <option value="faster-base">Faster Whisper Base</option>
                </select>
              </div>
            )}
            
            <Button
              variant="outline"
              size="sm"
              onClick={async () => {
                try {
                  const devices = await navigator.mediaDevices.enumerateDevices()
                  const inputs = devices.filter(d => d.kind === 'audioinput')
                  setAudioInputs(inputs)
                } catch {}
              }}
            >
              Refresh
            </Button>
          </div>
          
          <div className="flex gap-2 items-center">
            <Button variant={activeTab==='transcript'? 'default':'outline'} size="sm" onClick={() => setActiveTab('transcript')}>Transcript</Button>
            <Button variant={activeTab==='commands'? 'default':'outline'} size="sm" onClick={() => setActiveTab('commands')}>Actionable Commands</Button>
            {!isRunning ? (
              <Button size="sm" onClick={startCapture}>Start Live Transcript</Button>
            ) : (
              <Button variant="outline" size="sm" onClick={stopCapture}>Stop</Button>
            )}
          </div>
        </div>
      </CardHeader>
      
      <CardContent>
        {activeTab === 'transcript' ? (
          <div className="space-y-2">
            <div className="min-h-[160px] max-h-[280px] overflow-y-auto bg-secondary/30 rounded-lg p-3 border border-border">
              <p className="text-sm whitespace-pre-wrap leading-relaxed">{transcriptDisplayText}</p>
            </div>
          </div>
        ) : (
          <div className="space-y-3">
            {commands.length === 0 && (
              <p className="text-xs text-muted-foreground">No commands detected yet. They will appear here in real time.</p>
            )}
            <div className="grid grid-cols-1 gap-2">
              {commands.map((cmd, idx) => (
                <div key={idx} className="card-premium p-3">
                  <div className="flex items-start justify-between">
                    <div>
                      <div className="text-sm font-semibold text-foreground">{cmd.command_text}</div>
                      <div className="text-xs text-muted-foreground mt-1">{cmd.timestamp} ‚Ä¢ {cmd.who_said_it}</div>
                      <div className="text-xs text-foreground mt-2">Suggestion: {cmd.suggested_response}</div>
                    </div>
                    <Button size="sm" onClick={() => handlePolish(idx)}>Polish Response</Button>
                  </div>
                  {cmd.polished_response && (
                    <div className="mt-2 bg-secondary/30 rounded-md p-2 border border-border">
                      <div className="text-sm whitespace-pre-wrap leading-relaxed">{cmd.polished_response}</div>
                    </div>
                  )}
                </div>
              ))}
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  )
}

export default LiveTranscriptPanel;

===== END FILE: src\components\Transcription\LiveTranscriptPanel_backup.tsx =====

===== BEGIN FILE: src\components\ui\MarkdownRenderer.tsx =====
import React, { useMemo } from 'react';

interface MarkdownRendererProps {
  content: string;
  className?: string;
}

// Helper to process inline markdown: `code`, **bold**, *italic*, links
const renderInline = (text: string, keyPrefix: string) => {
  // Simple link autodetect (http/https)
  const urlRegex = /(https?:\/\/[^\s)]+)(\)|\s|$)/g;
  // Process inline code first to avoid styling inside code spans
  const segments = text.split('`');
  const parts: React.ReactNode[] = [];
  for (let i = 0; i < segments.length; i++) {
    const seg = segments[i];
    if (i % 2 === 1) {
      parts.push(
        <code key={`${keyPrefix}-code-${i}`} className="bg-stealth-card/50 text-stealth-primary px-2 py-1 rounded-md font-mono text-xs border border-stealth/30 backdrop-blur-sm">
          {seg}
        </code>
      );
    } else {
      // Bold and italic processing on non-code segments
      const boldSplit = seg.split('**');
      const boldParts: React.ReactNode[] = [];
      for (let j = 0; j < boldSplit.length; j++) {
        const bseg = boldSplit[j];
        if (j % 2 === 1) {
          boldParts.push(<strong key={`${keyPrefix}-b-${i}-${j}`} className="font-bold text-stealth-primary">{bseg}</strong>);
        } else {
          // Italic: *text*
          const italicSplit = bseg.split('*');
          for (let k = 0; k < italicSplit.length; k++) {
            const isItalic = k % 2 === 1;
            let chunk: React.ReactNode = italicSplit[k];
            // Links inside this chunk
            const withLinks: React.ReactNode[] = [];
            let lastIndex = 0;
            const strChunk = String(chunk);
            strChunk.replace(urlRegex, (match, url, _tail, offset) => {
              const before = strChunk.substring(lastIndex, offset);
              if (before) withLinks.push(before);
              withLinks.push(
                <a key={`${keyPrefix}-a-${i}-${j}-${k}-${offset}`} href={url} target="_blank" rel="noreferrer" className="text-stealth-primary underline decoration-stealth-primary/30 hover:decoration-stealth-primary/70 transition-colors duration-200">
                  {url}
                </a>
              );
              lastIndex = offset + String(url).length;
              return match;
            });
            const rest = strChunk.substring(lastIndex);
            if (rest) withLinks.push(rest);

            boldParts.push(
              <span key={`${keyPrefix}-i-${i}-${j}-${k}`} className={isItalic ? 'italic' : undefined}>
                {withLinks}
              </span>
            );
          }
        }
      }
      parts.push(<span key={`${keyPrefix}-seg-${i}`}>{boldParts}</span>);
    }
  }
  return parts;
};

const MarkdownRenderer: React.FC<MarkdownRendererProps> = ({ content, className = '' }) => {
  const elements = useMemo(() => {
    const lines = content.split('\n');
    const out: JSX.Element[] = [];
    let i = 0, key = 0;

    while (i < lines.length) {
      const line = lines[i];

      // Horizontal rule
      if (/^\s*(-{3,}|_{3,}|\*{3,})\s*$/.test(line)) {
        out.push(<hr key={`hr-${key++}`} className="my-4 border-t border-stealth/30" />);
        i++; continue;
      }

      // Blockquote / callout
      if (line.startsWith('>')) {
        const bq: string[] = [];
        while (i < lines.length && lines[i].startsWith('>')) {
          bq.push(lines[i].replace(/^>\s?/, ''));
          i++;
        }
        out.push(
          <div key={`bq-${key++}`} className="relative my-3 p-4 rounded-lg bg-stealth-card/30 border border-stealth/30 backdrop-blur-sm">
            <div className="absolute left-0 top-0 bottom-0 w-1 bg-stealth-primary/60 rounded-l-lg" />
            <div className="text-sm text-stealth-primary space-y-2">
              {bq.map((l, idx) => (
                <p key={`bq-p-${idx}`} className="leading-relaxed">{renderInline(l, `bq-${idx}`)}</p>
              ))}
            </div>
          </div>
        );
        continue;
      }

      // Headings
      if (/^###\s+/.test(line)) {
        out.push(<h3 key={`h3-${key++}`} className="mt-4 mb-2 text-sm font-bold text-stealth-primary">{line.replace(/^###\s+/, '')}</h3>);
        i++; continue;
      }
      if (/^##\s+/.test(line)) {
        out.push(
          <div key={`h2-${key++}`} className="mt-5 mb-3">
            <h2 className="text-base font-bold text-stealth-primary">{line.replace(/^##\s+/, '')}</h2>
            <div className="mt-2 h-px bg-gradient-to-r from-stealth-primary/40 via-stealth-primary/20 to-transparent" />
          </div>
        );
        i++; continue;
      }
      if (/^#\s+/.test(line)) {
        out.push(
          <div key={`h1-${key++}`} className="mt-6 mb-4">
            <h1 className="text-lg font-bold text-stealth-primary tracking-tight">{line.replace(/^#\s+/, '')}</h1>
            <div className="mt-3 h-px bg-gradient-to-r from-stealth-primary/60 via-stealth-primary/30 to-transparent" />
          </div>
        );
        i++; continue;
      }

      // Fenced code block ```lang
      if (/^```/.test(line)) {
        const lang = line.replace(/^```\s*/, '').trim();
        const code: string[] = [];
        i++;
        while (i < lines.length && !/^```/.test(lines[i])) {
          code.push(lines[i]);
          i++;
        }
        // skip closing ```
        if (i < lines.length && /^```/.test(lines[i])) i++;
        const codeText = code.join('\n');
        out.push(
          <div key={`code-${key++}`} className="my-4 rounded-xl border border-stealth/30 bg-stealth-card/20 backdrop-blur-sm overflow-hidden">
            <div className="flex items-center justify-between px-4 py-2 text-xs text-stealth-text-secondary bg-stealth-card/30">
              <span className="font-mono uppercase tracking-wider font-semibold">{lang || 'code'}</span>
              <button
                className="px-3 py-1 rounded-md bg-stealth-card/50 hover:bg-stealth-card/70 transition-all duration-200 hover-lift text-stealth-primary font-medium"
                onClick={() => navigator.clipboard.writeText(codeText)}
                title="Copy code"
              >Copy</button>
            </div>
            <pre className="p-4 text-xs leading-relaxed font-mono text-stealth-primary whitespace-pre overflow-x-auto">
              {codeText}
            </pre>
          </div>
        );
        continue;
      }

      // Bulleted list
      if (/^(-|\*)\s+/.test(line)) {
        const items: string[] = [line.replace(/^(-|\*)\s+/, '')];
        i++;
        while (i < lines.length && /^(-|\*)\s+/.test(lines[i])) {
          items.push(lines[i].replace(/^(-|\*)\s+/, ''));
          i++;
        }
        out.push(
          <ul key={`ul-${key++}`} className="my-3 ml-3 space-y-2">
            {items.map((it, idx) => (
              <li key={`uli-${idx}`} className="text-sm text-stealth-primary flex items-start">
                <span className="mt-2 mr-3 w-2 h-2 rounded-full bg-stealth-primary/70 flex-shrink-0" />
                <span className="leading-relaxed">{renderInline(it, `ul-${idx}`)}</span>
              </li>
            ))}
          </ul>
        );
        continue;
      }

      // Numbered list
      if (/^\d+\.\s+/.test(line)) {
        const items: string[] = [line.replace(/^\d+\.\s+/, '')];
        i++;
        while (i < lines.length && /^\d+\.\s+/.test(lines[i])) {
          items.push(lines[i].replace(/^\d+\.\s+/, ''));
          i++;
        }
        out.push(
          <ol key={`ol-${key++}`} className="my-3 ml-3 space-y-2">
            {items.map((it, idx) => (
              <li key={`oli-${idx}`} className="text-sm text-stealth-primary flex items-start">
                <span className="mt-0.5 mr-3 w-5 h-5 rounded-md bg-stealth-primary/20 text-stealth-primary text-xs flex items-center justify-center font-bold flex-shrink-0 border border-stealth/30">{idx + 1}</span>
                <span className="leading-relaxed">{renderInline(it, `ol-${idx}`)}</span>
              </li>
            ))}
          </ol>
        );
        continue;
      }

      // Simple tables | a | b |
      if (/^\|.+\|$/.test(line)) {
        const rows: string[][] = [];
        while (i < lines.length && /^\|.+\|$/.test(lines[i])) {
          const cells = lines[i].split('|').slice(1, -1).map(c => c.trim());
          rows.push(cells);
          i++;
        }
        out.push(
          <div key={`tbl-${key++}`} className="my-4 overflow-x-auto rounded-xl border border-stealth/30 bg-stealth-card/20 backdrop-blur-sm">
            <table className="w-full text-left text-xs">
              <tbody>
                {rows.map((r, ri) => (
                  <tr key={`tr-${ri}`} className={ri === 0 ? 'bg-stealth-card/30' : ri % 2 === 0 ? 'bg-transparent' : 'bg-stealth-card/10'}>
                    {r.map((c, ci) => (
                      <td key={`td-${ri}-${ci}`} className="px-4 py-3 text-stealth-primary border-t border-stealth/20 first:border-l-0">{renderInline(c, `td-${ri}-${ci}`)}</td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        );
        continue;
      }

      // Empty line -> spacer
      if (line.trim() === '') { i++; continue; }

      // Paragraph
      out.push(
        <p key={`p-${key++}`} className="text-sm text-stealth-primary leading-relaxed mb-3">
          {renderInline(line, `p-${key}`)}
        </p>
      );
      i++;
    }

    return out;
  }, [content]);

  return (
    <div className={`max-w-none ${className}`}>
      {elements}
    </div>
  );
};

export default MarkdownRenderer;

===== END FILE: src\components\ui\MarkdownRenderer.tsx =====

===== BEGIN FILE: src\components\ui\ModelSelector.tsx =====
import React, { useState, useEffect } from 'react';
import { Button } from './button';
import { Input } from './input';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from './card';
import { Label } from './label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './select';
import { Badge } from './badge';
import { Separator } from './separator';

interface ModelConfig {
  provider: "ollama" | "gemini";
  model: string;
  isOllama: boolean;
}

interface ModelSelectorProps {
  onModelChange?: (provider: "ollama" | "gemini", model: string) => void;
}

const ModelSelector: React.FC<ModelSelectorProps> = ({ onModelChange }) => {
  const [currentConfig, setCurrentConfig] = useState<ModelConfig | null>(null);
  const [availableOllamaModels, setAvailableOllamaModels] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [connectionStatus, setConnectionStatus] = useState<'testing' | 'success' | 'error' | null>(null);
  const [errorMessage, setErrorMessage] = useState<string>('');
  const [geminiApiKey, setGeminiApiKey] = useState('');
  const [selectedProvider, setSelectedProvider] = useState<"ollama" | "gemini">("gemini");
  const [selectedOllamaModel, setSelectedOllamaModel] = useState<string>("");
  const [ollamaUrl, setOllamaUrl] = useState<string>("http://localhost:11434");

  useEffect(() => {
    loadCurrentConfig();
  }, []);

  const loadCurrentConfig = async () => {
    try {
      setIsLoading(true);
      const config = await window.electronAPI.getCurrentLlmConfig();
      setCurrentConfig(config);
      setSelectedProvider(config.provider);
      
      if (config.isOllama) {
        setSelectedOllamaModel(config.model);
        await loadOllamaModels();
      }
    } catch (error) {
      console.error('Error loading current config:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const loadOllamaModels = async () => {
    try {
      const models = await window.electronAPI.getAvailableOllamaModels();
      setAvailableOllamaModels(models);
      
      // Auto-select first model if none selected
      if (models.length > 0 && !selectedOllamaModel) {
        setSelectedOllamaModel(models[0]);
      }
    } catch (error) {
      console.error('Error loading Ollama models:', error);
      setAvailableOllamaModels([]);
    }
  };

  const testConnection = async () => {
    try {
      setConnectionStatus('testing');
      const result = await window.electronAPI.testLlmConnection();
      setConnectionStatus(result.success ? 'success' : 'error');
      if (!result.success) {
        setErrorMessage(result.error || 'Unknown error');
      }
    } catch (error) {
      setConnectionStatus('error');
      setErrorMessage(String(error));
    }
  };

  const handleProviderSwitch = async () => {
    try {
      setConnectionStatus('testing');
      let result;
      
      if (selectedProvider === 'ollama') {
        result = await window.electronAPI.switchToOllama(selectedOllamaModel, ollamaUrl);
      } else {
        result = await window.electronAPI.switchToGemini(geminiApiKey || undefined);
      }

      if (result.success) {
        await loadCurrentConfig();
        setConnectionStatus('success');
        onModelChange?.(selectedProvider, selectedProvider === 'ollama' ? selectedOllamaModel : 'MindWhisper AI');
      } else {
        setConnectionStatus('error');
        setErrorMessage(result.error || 'Switch failed');
      }
    } catch (error) {
      setConnectionStatus('error');
      setErrorMessage(String(error));
    }
  };

  const getStatusColor = () => {
    switch (connectionStatus) {
      case 'testing': return 'text-gray-700';
      case 'success': return 'text-black';
      case 'error': return 'text-black';
      default: return 'text-gray-600';
    }
  };

  const getStatusText = () => {
    switch (connectionStatus) {
      case 'testing': return 'Testing connection...';
      case 'success': return 'Connected successfully';
      case 'error': return `Error: ${errorMessage}`;
      default: return 'Ready';
    }
  };

  if (isLoading) {
    return (
      <div className="p-4 bg-secondary/30 rounded-lg border border-border">
        <div className="animate-pulse text-sm text-muted-foreground">Loading model configuration...</div>
      </div>
    );
  }

  return (
    <div className="space-y-2 animate-cmd-enter">
      {/* Status Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-2">
          <div className="w-2 h-2 rounded-full bg-foreground animate-pulse"></div>
          <span className="text-sm font-semibold text-foreground">AI Provider</span>
        </div>
        <div className="text-xs text-muted-foreground">
          {getStatusText()}
        </div>
      </div>

      {/* Current Model Display */}
      {currentConfig && (
        <Card className="card-premium">
          <CardContent className="p-3">
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-3">
                <div className="w-8 h-8 rounded-lg flex items-center justify-center bg-gradient-to-br from-primary/20 to-primary/10 border border-primary/20">
                  <span className="text-primary text-sm font-semibold">
                    {currentConfig.provider === 'ollama' ? '‚ö°' : '‚òÅ'}
                  </span>
                </div>
                <div className="flex-1">
                  <div className="flex items-center gap-2">
                    <h4 className="text-sm font-semibold text-foreground">
                      {currentConfig.provider === 'ollama' ? 'Local' : 'Cloud'}
                    </h4>
                    <Badge variant="success" className="text-[10px] px-1.5 py-0.5">
                      Active
                    </Badge>
                  </div>
                  <p className="text-xs text-muted-foreground truncate max-w-[180px] mt-0.5">
                    {currentConfig.provider === 'gemini' ? 'MindWhisper AI' : currentConfig.model}
                  </p>
                </div>
              </div>
              <div className="w-2 h-2 bg-emerald-400 rounded-full animate-pulse"></div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Provider Selection */}
      <div className="space-y-3">
        <Label className="text-sm font-semibold text-foreground">AI Provider</Label>
        <div className="grid grid-cols-2 gap-2">
          <Button
            onClick={() => setSelectedProvider('gemini')}
            variant={selectedProvider === 'gemini' ? 'default' : 'outline'}
            className="h-12 rounded-xl transition-all duration-200 hover:-translate-y-1 hover:shadow-stealth-md group"
          >
            <div className="flex flex-col items-center space-y-1">
              <div className="w-6 h-6 rounded-lg bg-gradient-to-br from-blue-500/20 to-blue-600/10 flex items-center justify-center border border-blue-500/20 group-hover:border-blue-500/40 transition-colors">
                <span className="text-blue-500 text-sm">‚òÅ</span>
              </div>
              <span className="text-xs font-medium">MindWhisper AI</span>
            </div>
          </Button>
          <Button
            onClick={() => setSelectedProvider('ollama')}
            variant={selectedProvider === 'ollama' ? 'default' : 'outline'}
            className="h-12 rounded-xl transition-all duration-200 hover:-translate-y-1 hover:shadow-stealth-md group"
          >
            <div className="flex flex-col items-center space-y-1">
              <div className="w-6 h-6 rounded-lg bg-gradient-to-br from-amber-500/20 to-amber-600/10 flex items-center justify-center border border-amber-500/20 group-hover:border-amber-500/40 transition-colors">
                <span className="text-amber-500 text-sm">‚ö°</span>
              </div>
              <span className="text-xs font-medium">Ollama</span>
            </div>
          </Button>
        </div>
      </div>

      <Separator className="my-4" />
      
      {/* Provider-specific Configuration */}
      <Card className="card-premium">
        <CardContent className="p-4 space-y-4">
        {selectedProvider === 'gemini' ? (
          <div className="space-y-2">
            <div className="flex items-center space-x-2">
              <div className="w-5 h-5 rounded-sm bg-primary flex items-center justify-center">
                <svg className="w-3 h-3 text-primary-foreground" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 7a2 2 0 012 2m0 0a2 2 0 012 2m-2-2a2 2 0 00-2 2m2-2V5a2 2 0 00-2-2" />
                </svg>
              </div>
              <h5 className="text-xs font-semibold text-foreground">MindWhisper AI</h5>
            </div>
            <div className="text-[11px] text-muted-foreground">No API setup required.</div>
          </div>
        ) : (
          <div className="space-y-2">
            <div className="flex items-center space-x-2">
              <div className="w-5 h-5 rounded-sm bg-primary flex items-center justify-center">
                <svg className="w-3 h-3 text-primary-foreground" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2H5a2 2 0 00-2-2z" />
                </svg>
              </div>
              <h5 className="text-xs font-semibold text-foreground">Local Configuration</h5>
            </div>
            
            <div>
              <label className="block text-[11px] font-medium text-foreground mb-1">Server URL</label>
              <Input
                type="url"
                value={ollamaUrl}
                onChange={(e) => setOllamaUrl(e.target.value)}
                className="w-full h-8 text-xs"
                placeholder="http://localhost:11434"
              />
            </div>
            
            <div>
              <div className="flex items-center justify-between mb-1">
                <label className="text-[11px] font-medium text-foreground">Models</label>
                <Button
                  onClick={loadOllamaModels}
                  variant="outline"
                  size="sm"
                  className="px-2 py-0.5 text-[11px] h-6 hover:-translate-y-0.5 transition-all"
                  title="Refresh model list"
                >
                  <svg className="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                  </svg>
                  Refresh
                </Button>
              </div>
              
              {availableOllamaModels.length > 0 ? (
                <Select value={selectedOllamaModel} onValueChange={setSelectedOllamaModel}>
                  <SelectTrigger className="h-8 text-xs">
                    <SelectValue placeholder="Select model" />
                  </SelectTrigger>
                  <SelectContent>
                    {availableOllamaModels.map((model) => (
                      <SelectItem key={model} value={model}>
                        <div className="flex items-center gap-2">
                          <div className="w-2 h-2 rounded-full bg-emerald-400"></div>
                          <span>{model}</span>
                        </div>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              ) : (
                <div className="card-premium p-2 flex items-center space-x-2">
                  <svg className="w-3 h-3 text-muted-foreground" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z" />
                  </svg>
                  <div>
                    <p className="text-[11px] font-medium text-foreground">No models found</p>
                    <p className="text-[11px] text-muted-foreground">Ensure Ollama is running</p>
                  </div>
                </div>
              )}
            </div>
          </div>
        )}
      </CardContent>
      </Card>

      {/* Action Buttons */}
      <div className="flex gap-3">
        <Button
          onClick={handleProviderSwitch}
          disabled={connectionStatus === 'testing'}
          className="flex-1 h-10 text-sm disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center space-x-2 hover:-translate-y-0.5 transition-all duration-200"
        >
          {connectionStatus === 'testing' ? (
            <>
              <div className="loading-dots">
                <span></span>
                <span></span>
                <span></span>
              </div>
              <span>Applying...</span>
            </>
          ) : (
            <>
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
              </svg>
              <span>Apply Changes</span>
            </>
          )}
        </Button>
        
        <Button
          onClick={testConnection}
          disabled={connectionStatus === 'testing'}
          variant="outline"
          className="px-4 h-10 text-sm disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-2 hover:-translate-y-0.5 transition-all duration-200"
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
          </svg>
          <span>Test</span>
        </Button>
      </div>

      <Separator className="my-4" />
      
      {/* Information (collapsed by default to save space) */}
      <details className="group">
        <summary className="cursor-pointer flex items-center gap-3 p-3 rounded-xl hover:bg-stealth-card/30 transition-all duration-200">
          <div className="w-6 h-6 rounded-lg bg-gradient-to-br from-primary/20 to-primary/10 flex items-center justify-center border border-primary/20">
            <span className="text-primary text-sm">i</span>
          </div>
          <span className="text-sm font-semibold text-foreground">Provider Comparison</span>
          <svg className="w-4 h-4 ml-auto text-muted-foreground transition-transform duration-200 group-open:rotate-180" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
          </svg>
        </summary>
        <div className="mt-3 p-3 space-y-3 bg-stealth-card/20 rounded-xl border border-stealth-border/50">
          <div className="flex items-center justify-between p-2 rounded-lg bg-blue-500/10 border border-blue-500/20">
            <div className="flex items-center gap-2">
              <span className="text-blue-500">‚òÅ</span>
              <span className="font-medium text-foreground text-sm">MindWhisper AI</span>
            </div>
            <div className="flex gap-2">
              <Badge variant="outline" className="text-xs">Fast</Badge>
              <Badge variant="outline" className="text-xs">Cloud</Badge>
            </div>
          </div>
          <div className="flex items-center justify-between p-2 rounded-lg bg-amber-500/10 border border-amber-500/20">
            <div className="flex items-center gap-2">
              <span className="text-amber-500">‚ö°</span>
              <span className="font-medium text-foreground text-sm">Ollama</span>
            </div>
            <div className="flex gap-2">
              <Badge variant="outline" className="text-xs">Private</Badge>
              <Badge variant="outline" className="text-xs">Local</Badge>
            </div>
          </div>
        </div>
      </details>
    </div>
  );
};

export default ModelSelector;
===== END FILE: src\components\ui\ModelSelector.tsx =====

===== BEGIN FILE: src\components\ui\StealthControls.tsx =====
// Ultra-Modern Stealth Controls Component
import React, { useState, useEffect } from 'react'
import { Button } from './button'
import { Separator } from './separator'

interface StealthControlsProps {
  onOpacityChange?: (opacity: number) => void
  onStealthModeToggle?: (enabled: boolean) => void
  className?: string
}

const StealthControls: React.FC<StealthControlsProps> = ({
  onOpacityChange,
  onStealthModeToggle,
  className = ""
}) => {
  const [opacity, setOpacity] = useState(95)
  const [stealthMode, setStealthMode] = useState(false)
  const [ultraStealthMode, setUltraStealthMode] = useState(false)

  // Restore saved opacity on mount, if available
  useEffect(() => {
    try {
      const saved = localStorage.getItem('stealth.opacity')
      if (saved != null) {
        const parsed = parseInt(saved, 10)
        if (!Number.isNaN(parsed) && parsed >= 5 && parsed <= 100) {
          setOpacity(parsed)
          // Also apply immediately so the CSS var is set even before user interaction
          const opacityValue = parsed / 100
          document.documentElement.style.setProperty('--stealth-opacity', opacityValue.toString())
          onOpacityChange?.(opacityValue)
        }
      }
      const savedStealth = localStorage.getItem('stealth.mode')
      const savedUltra = localStorage.getItem('stealth.mode.ultra')
      if (savedStealth != null) setStealthMode(savedStealth === '1')
      if (savedUltra != null) setUltraStealthMode(savedUltra === '1')
    } catch {}
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  // Update CSS custom property when opacity changes
  useEffect(() => {
    const opacityValue = opacity / 100
    document.documentElement.style.setProperty('--stealth-opacity', opacityValue.toString())
    onOpacityChange?.(opacityValue)
    try {
      localStorage.setItem('stealth.opacity', String(opacity))
    } catch {}
  }, [opacity, onOpacityChange])

  // Apply stealth mode classes
  useEffect(() => {
    const body = document.body
    const app = document.getElementById('root') || document.getElementById('app')
    
    if (ultraStealthMode) {
      body.classList.add('stealth-ultra')
      app?.classList.add('stealth-ultra')
      // Apply undetectable filter adjustments for added stealth
      body.classList.add('undetectable')
      app?.classList.add('undetectable')
    } else if (stealthMode) {
      body.classList.add('stealth-mode')
      app?.classList.add('stealth-mode')
      body.classList.remove('stealth-ultra')
      app?.classList.remove('stealth-ultra')
      // Apply undetectable filter adjustments for added stealth
      body.classList.add('undetectable')
      app?.classList.add('undetectable')
    } else {
      body.classList.remove('stealth-mode', 'stealth-ultra')
      app?.classList.remove('stealth-mode', 'stealth-ultra')
      // Remove undetectable filters when not in stealth
      body.classList.remove('undetectable')
      app?.classList.remove('undetectable')
    }

    onStealthModeToggle?.(stealthMode || ultraStealthMode)
    try {
      localStorage.setItem('stealth.mode', stealthMode ? '1' : '0')
      localStorage.setItem('stealth.mode.ultra', ultraStealthMode ? '1' : '0')
    } catch {}
  }, [stealthMode, ultraStealthMode, onStealthModeToggle])

  const handleOpacityChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setOpacity(parseInt(event.target.value))
  }

  const toggleStealthMode = () => {
    if (ultraStealthMode) {
      setUltraStealthMode(false)
      setStealthMode(false)
    } else if (stealthMode) {
      setStealthMode(false)
      setUltraStealthMode(true)
    } else {
      setStealthMode(true)
    }
  }

  const quickOpacityPresets = [
    { label: '100%', value: 100 },
    { label: '90%', value: 90 },
    { label: '75%', value: 75 },
    { label: '50%', value: 50 },
    { label: '25%', value: 25 },
    { label: '10%', value: 10 }
  ]

  return (
    <div className={`space-y-5 ${className}`}>
        {/* Premium Transparency Control */}
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <label className="text-sm font-semibold text-stealth-primary">
              Transparency
            </label>
            <span className="text-xs font-mono text-stealth-primary bg-stealth-card/50 px-3 py-1.5 rounded-lg border border-stealth/30 backdrop-blur-sm">
              {opacity}%
            </span>
          </div>
          
          <div className="relative">
            <input
              type="range"
              min="5"
              max="100"
              value={opacity}
              onChange={handleOpacityChange}
              className="w-full h-3 bg-stealth-card/30 rounded-full appearance-none cursor-pointer stealth-slider transition-all duration-200 hover:h-3.5"
              style={{
                background: `linear-gradient(to right, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.4) ${opacity}%, rgba(255,255,255,0.08) ${opacity}%, rgba(255,255,255,0.08) 100%)`
              }}
            />
          </div>

          {/* Premium Quick Presets */}
          <div className="grid grid-cols-6 gap-2">
            {quickOpacityPresets.map((preset) => (
              <Button
                key={preset.value}
                variant={opacity === preset.value ? "default" : "ghost"}
                size="sm"
                onClick={() => setOpacity(preset.value)}
                className={`h-7 text-xs px-2 font-medium transition-all duration-200 hover-lift spring-bounce ${
                  opacity === preset.value 
                    ? 'bg-stealth-primary text-stealth-primary-foreground shadow-sm' 
                    : 'text-stealth-text-secondary hover:text-stealth-primary hover:bg-stealth-card/50'
                }`}
              >
                {preset.label}
              </Button>
            ))}
          </div>
        </div>

        <Separator className="my-5" />

        {/* Premium Stealth Mode Toggle */}
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <label className="text-sm font-semibold text-stealth-primary">
              Stealth Mode
            </label>
            <div className="flex items-center gap-2">
              {stealthMode && (
                <div className="w-2.5 h-2.5 bg-emerald-400 rounded-full animate-pulse shadow-[0_0_8px_rgba(16,185,129,0.4)]" />
              )}
              {ultraStealthMode && (
                <div className="w-2.5 h-2.5 bg-rose-400 rounded-full animate-pulse shadow-[0_0_8px_rgba(244,63,94,0.4)]" />
              )}
            </div>
          </div>

          <Button
            onClick={toggleStealthMode}
            variant={stealthMode || ultraStealthMode ? "default" : "outline"}
            size="sm"
            className="w-full justify-start gap-3 h-10 hover-lift spring-bounce"
          >
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L12 12m6.121-6.121A2.98 2.98 0 0119 8c0 .597-.176 1.152-.487 1.618m-7.681 8.207l6.294-6.294" />
            </svg>
            <span className="font-semibold">
              {ultraStealthMode ? 'Ultra Stealth' : stealthMode ? 'Stealth Active' : 'Normal Mode'}
            </span>
          </Button>

          <div className="text-xs text-stealth-text-secondary space-y-1.5 bg-stealth-card/30 p-3 rounded-lg border border-stealth/20">
            <p className="flex items-center gap-2">‚Ä¢ <span className="font-medium">Normal:</span> Full visibility</p>
            <p className="flex items-center gap-2">‚Ä¢ <span className="font-medium">Stealth:</span> Optimized for screen sharing</p>
            <p className="flex items-center gap-2">‚Ä¢ <span className="font-medium">Ultra:</span> Nearly invisible (emergency mode)</p>
          </div>
        </div>

        <Separator className="my-5" />

        {/* Premium Screen Share Protection */}
        <div className="space-y-4">
          <label className="text-sm font-semibold text-stealth-primary">
            Screen Share Protection
          </label>
          
          <div className="grid grid-cols-2 gap-3">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setOpacity(5)}
              className="text-xs font-medium h-9 hover-lift spring-bounce bg-rose-500/5 border-rose-400/30 hover:bg-rose-500/10"
            >
              Hide Instantly
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={() => {
                setOpacity(95)
                setStealthMode(false)
                setUltraStealthMode(false)
              }}
              className="text-xs font-medium h-9 hover-lift spring-bounce bg-emerald-500/5 border-emerald-400/30 hover:bg-emerald-500/10"
            >
              Show Normal
            </Button>
          </div>
        </div>
    </div>
  )
}

export default StealthControls

===== END FILE: src\components\ui\StealthControls.tsx =====

===== BEGIN FILE: src\components\ui\badge.tsx =====
// src/components/ui/badge.tsx - Premium Badge System

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "../../lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center gap-1 whitespace-nowrap rounded-lg text-xs font-semibold transition-all duration-200 ease-out transform-gpu",
  {
    variants: {
      variant: {
        default: [
          "bg-stealth-card text-stealth-primary border border-stealth shadow-sm backdrop-blur-sm",
          "hover:shadow-md hover:-translate-y-0.5",
          "active:translate-y-0 active:scale-95"
        ],
        secondary: [
          "bg-stealth-bg-secondary text-stealth-text-secondary border border-stealth shadow-sm backdrop-blur-sm",
          "hover:bg-stealth-card hover:text-stealth-primary hover:shadow-md hover:-translate-y-0.5",
          "active:translate-y-0 active:scale-95"
        ],
        destructive: [
          "bg-destructive text-destructive-foreground shadow-sm",
          "hover:bg-destructive/90 hover:shadow-md hover:-translate-y-0.5",
          "active:translate-y-0 active:scale-95"
        ],
        outline: [
          "border border-stealth bg-transparent text-stealth-primary shadow-sm",
          "hover:bg-stealth-card hover:shadow-md hover:-translate-y-0.5 backdrop-blur-sm",
          "active:translate-y-0 active:scale-95"
        ],
        success: [
          "bg-emerald-500/20 text-emerald-200 border border-emerald-400/30 shadow-sm backdrop-blur-sm",
          "hover:bg-emerald-500/30 hover:shadow-md hover:-translate-y-0.5",
          "active:translate-y-0 active:scale-95"
        ],
        warning: [
          "bg-amber-500/20 text-amber-200 border border-amber-400/30 shadow-sm backdrop-blur-sm",
          "hover:bg-amber-500/30 hover:shadow-md hover:-translate-y-0.5",
          "active:translate-y-0 active:scale-95"
        ]
      },
      size: {
        sm: "h-5 px-2 text-[10px] rounded-md",
        default: "h-6 px-2.5 text-xs rounded-lg",
        lg: "h-7 px-3 text-sm rounded-lg"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, size, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant, size }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
export default Badge

===== END FILE: src\components\ui\badge.tsx =====

===== BEGIN FILE: src\components\ui\button.tsx =====
// src/components/ui/button.tsx - Premium Button System

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "../../lib/utils"

const buttonVariants = cva(
  "relative inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-xl text-sm font-semibold transition-all duration-200 ease-out focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 overflow-hidden transform-gpu",
  {
    variants: {
      variant: {
        default: [
          // Glass primary bound to stealth opacity
          "bg-stealth-card text-stealth-primary border border-stealth shadow-[0_1px_3px_0_rgba(0,0,0,0.1),0_1px_2px_0_rgba(0,0,0,0.06)] backdrop-blur-sm",
          "hover:shadow-[0_10px_15px_-3px_rgba(0,0,0,0.1),0_4px_6px_-2px_rgba(0,0,0,0.05)]",
          "hover:-translate-y-0.5",
          "active:translate-y-0 active:scale-95",
          "before:absolute before:inset-0 before:bg-gradient-to-r before:from-transparent before:via-white/10 before:to-transparent",
          "before:-translate-x-full before:transition-transform before:duration-500",
          "hover:before:translate-x-full"
        ],
        secondary: [
          // Stealth glass background bound to --stealth-opacity
          "bg-stealth-card text-stealth-primary border border-stealth shadow-[0_1px_2px_0_rgba(0,0,0,0.05)] backdrop-blur-sm",
          "hover:shadow-[0_4px_6px_-1px_rgba(0,0,0,0.1),0_2px_4px_-1px_rgba(0,0,0,0.06)]",
          "hover:-translate-y-0.5",
          "active:translate-y-0 active:scale-95"
        ],
        outline: [
          // Transparent, with stealth glass hover
          "border border-stealth bg-transparent text-stealth-primary shadow-[0_1px_2px_0_rgba(0,0,0,0.05)]",
          "hover:bg-stealth-card hover:shadow-[0_4px_6px_-1px_rgba(0,0,0,0.1),0_2px_4px_-1px_rgba(0,0,0,0.06)] backdrop-blur-sm",
          "hover:-translate-y-0.5",
          "active:translate-y-0 active:scale-95"
        ],
        ghost: [
          // Transparent, with stealth glass hover
          "bg-transparent text-stealth-primary",
          "hover:bg-stealth-card hover:shadow-[0_1px_2px_0_rgba(0,0,0,0.05)] backdrop-blur-sm",
          "hover:-translate-y-0.5",
          "active:translate-y-0 active:scale-95"
        ],
        destructive: [
          "bg-destructive text-destructive-foreground shadow-[0_1px_3px_0_rgba(0,0,0,0.1),0_1px_2px_0_rgba(0,0,0,0.06)]",
          "hover:bg-destructive/90 hover:shadow-[0_10px_15px_-3px_rgba(0,0,0,0.1),0_4px_6px_-2px_rgba(0,0,0,0.05)]",
          "hover:-translate-y-0.5",
          "active:translate-y-0 active:scale-95"
        ],
        link: [
          "text-primary underline-offset-4 hover:underline",
          "hover:-translate-y-0.5",
          "active:translate-y-0"
        ]
      },
      size: {
        default: "h-10 px-4 py-2 text-sm rounded-xl",
        sm: "h-8 px-3 text-xs rounded-lg",
        lg: "h-12 px-6 text-base rounded-xl",
        xl: "h-14 px-8 text-lg rounded-2xl",
        icon: "h-10 w-10 rounded-xl"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size }), className)}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

===== END FILE: src\components\ui\button.tsx =====

===== BEGIN FILE: src\components\ui\card.tsx =====
// src/components/ui/card.tsx - Premium Card System

import * as React from "react"
import { cn } from "../../lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      // Use glassmorphism card by default for stealth transparency
      "card-premium",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-2 p-6 pb-4", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-tight tracking-tight text-foreground",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground font-medium", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-4 border-t border-border/50", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
===== END FILE: src\components\ui\card.tsx =====

===== BEGIN FILE: src\components\ui\dialog.tsx =====
// src/components/ui/dialog.tsx - Premium Dialog System

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"
import { cn } from "../../lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 backdrop-blur-xl transition-all duration-300 ease-out",
      "bg-stealth-bg-primary/80 data-[state=open]:animate-in data-[state=closed]:animate-out",
      "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%]",
        "gap-6 card-floating p-8 shadow-2xl duration-300 ease-out",
        "data-[state=open]:animate-in data-[state=closed]:animate-out",
        "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        "data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
        "data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%]",
        "data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%]",
        "sm:rounded-2xl border-stealth backdrop-blur-xl",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-6 top-6 rounded-lg opacity-70 ring-offset-background transition-all duration-200 hover:opacity-100 hover:bg-stealth-card hover:scale-110 focus:outline-none focus:ring-2 focus:ring-stealth-border focus:ring-offset-2 disabled:pointer-events-none p-1">
        <X className="h-4 w-4 text-stealth-primary" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-3 gap-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-xl font-semibold leading-tight tracking-tight text-stealth-primary",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-stealth-text-secondary leading-relaxed", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

===== END FILE: src\components\ui\dialog.tsx =====

===== BEGIN FILE: src\components\ui\dropdown-menu.tsx =====
// src/components/ui/dropdown-menu.tsx - Premium Dropdown Menu System

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"
import { cn } from "../../lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-lg px-2 py-1.5 text-sm outline-none",
      "focus:bg-stealth-card/60 data-[state=open]:bg-stealth-card/60",
      "hover:bg-stealth-card/40 transition-all duration-150 ease-out",
      "text-stealth-text-secondary hover:text-stealth-primary",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-xl border border-stealth-border bg-stealth-card/95 backdrop-blur-xl p-1 shadow-stealth-lg",
      "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
      "data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-xl border border-stealth-border bg-stealth-card/95 backdrop-blur-xl p-1 shadow-stealth-lg",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
        "data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-lg px-2 py-1.5 text-sm outline-none transition-all duration-150 ease-out",
      "focus:bg-stealth-card/60 focus:text-stealth-primary data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      "hover:bg-stealth-card/40 hover:text-stealth-primary",
      "text-stealth-text-secondary",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-lg py-1.5 pl-8 pr-2 text-sm outline-none transition-all duration-150 ease-out",
      "focus:bg-stealth-card/60 focus:text-stealth-primary data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      "hover:bg-stealth-card/40 hover:text-stealth-primary",
      "text-stealth-text-secondary data-[state=checked]:text-stealth-primary data-[state=checked]:font-medium",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-lg py-1.5 pl-8 pr-2 text-sm outline-none transition-all duration-150 ease-out",
      "focus:bg-stealth-card/60 focus:text-stealth-primary data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      "hover:bg-stealth-card/40 hover:text-stealth-primary",
      "text-stealth-text-secondary data-[state=checked]:text-stealth-primary data-[state=checked]:font-medium",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-stealth-primary",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-stealth-border", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest text-stealth-text-muted opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

===== END FILE: src\components\ui\dropdown-menu.tsx =====

===== BEGIN FILE: src\components\ui\input.tsx =====
// src/components/ui/input.tsx - Premium Input System

import * as React from "react"
import { cn } from "../../lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type = "text", ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          // Use premium glass input by default for stealth transparency
          "input-premium h-11 rounded-xl px-4 py-3 text-sm font-medium",
          // Preserve legacy states and file input compatibility
          "disabled:cursor-not-allowed",
          "file:border-0 file:bg-transparent file:text-sm file:font-medium",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

===== END FILE: src\components\ui\input.tsx =====

===== BEGIN FILE: src\components\ui\label.tsx =====
// src/components/ui/label.tsx - Premium Label System

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "../../lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 transition-all duration-200 ease-out",
  {
    variants: {
      variant: {
        default: "text-stealth-primary",
        muted: "text-stealth-text-muted",
        secondary: "text-stealth-text-secondary"
      },
      size: {
        sm: "text-xs",
        default: "text-sm",
        lg: "text-base"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, variant, size, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants({ variant, size }), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

===== END FILE: src\components\ui\label.tsx =====

===== BEGIN FILE: src\components\ui\popover.tsx =====
// src/components/ui/popover.tsx - Premium Popover System

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"
import { cn } from "../../lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-xl border border-stealth-border bg-stealth-card/95 backdrop-blur-xl p-4 shadow-stealth-lg outline-none",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
        "data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }

===== END FILE: src\components\ui\popover.tsx =====

===== BEGIN FILE: src\components\ui\select.tsx =====
// src/components/ui/select.tsx - Premium Select System

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"
import { cn } from "../../lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-lg border border-stealth-border bg-stealth-card/30 px-3 py-2 text-sm",
      "ring-offset-stealth-bg-primary placeholder:text-stealth-text-muted",
      "focus:outline-none focus:ring-2 focus:ring-stealth-border focus:ring-offset-2",
      "disabled:cursor-not-allowed disabled:opacity-50",
      "backdrop-blur-sm transition-all duration-200 ease-out",
      "hover:bg-stealth-card/50 hover:border-stealth-border-hover hover:shadow-stealth-sm hover:-translate-y-0.5",
      "data-[state=open]:bg-stealth-card/60 data-[state=open]:border-stealth-border-active data-[state=open]:shadow-stealth-md",
      "text-stealth-primary font-medium",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50 transition-transform duration-200 data-[state=open]:rotate-180" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-xl border border-stealth-border bg-stealth-card/95 backdrop-blur-xl shadow-stealth-lg",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
        position === "popper" ?
          "data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2" : "",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" ?
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]" : ""
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold text-stealth-primary", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-lg py-2 pl-8 pr-2 text-sm outline-none",
      "focus:bg-stealth-card/60 focus:text-stealth-primary data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      "hover:bg-stealth-card/40 transition-all duration-150 ease-out",
      "text-stealth-text-secondary data-[state=checked]:text-stealth-primary data-[state=checked]:font-medium",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-stealth-border", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

===== END FILE: src\components\ui\select.tsx =====

===== BEGIN FILE: src\components\ui\separator.tsx =====
// src/components/ui/separator.tsx - Premium Separator System

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"
import { cn } from "../../lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 transition-all duration-200 ease-out",
        orientation === "horizontal" 
          ? "h-px w-full bg-gradient-to-r from-transparent via-stealth-border to-transparent" 
          : "h-full w-px bg-gradient-to-b from-transparent via-stealth-border to-transparent",
        "opacity-60 hover:opacity-100",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

===== END FILE: src\components\ui\separator.tsx =====

===== BEGIN FILE: src\components\ui\toast.tsx =====
import * as React from "react"
import * as ToastPrimitive from "@radix-ui/react-toast"
import { cn } from "../../lib/utils"
import { X } from "lucide-react"

const ToastProvider = ToastPrimitive.Provider

export type ToastMessage = {
  title: string
  description: string
  variant: ToastVariant
}

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitive.Viewport
    ref={ref}
    className={cn(
      // Fixed, unobtrusive viewport that hugs the top-right corner
      "pointer-events-none fixed top-5 left-0 right-0 z-[140] flex flex-col items-end gap-3 px-4 sm:px-6",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitive.Viewport.displayName

type ToastVariant = "neutral" | "success" | "error"

interface ToastProps
  extends React.ComponentPropsWithoutRef<typeof ToastPrimitive.Root> {
  variant?: ToastVariant
}

const toastVariants: Record<ToastVariant, string> = {
  neutral: "border-stealth/30 shadow-[0_8px_30px_rgb(0,0,0,0.12)]",
  success: "border-emerald-400/40 shadow-[0_8px_30px_rgba(16,185,129,0.15)] bg-gradient-to-br from-emerald-500/5 to-transparent",
  error: "border-rose-400/50 shadow-[0_8px_30px_rgba(244,63,94,0.2)] bg-gradient-to-br from-rose-500/5 to-transparent"
}

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitive.Root>,
  ToastProps
>(({ className, variant = "neutral", ...props }, ref) => (
  <ToastPrimitive.Root
    ref={ref}
    className={cn(
      "group relative z-[150] w-full max-w-[calc(100vw-3rem)] sm:max-w-sm overflow-hidden rounded-xl border bg-stealth-card/95 px-4 py-3.5",
      "pointer-events-auto backdrop-blur-xl transition-all duration-300 ease-out",
      "hover:scale-[1.02] hover:shadow-[0_12px_40px_rgba(0,0,0,0.15)]",
      "before:absolute before:inset-0 before:-z-10 before:bg-gradient-to-br before:from-white/8 before:via-transparent before:to-transparent",
      "animate-in slide-in-from-top-2 fade-in-0 duration-300",
      "data-[state=closed]:animate-out data-[state=closed]:slide-out-to-top-2 data-[state=closed]:fade-out-0 data-[state=closed]:duration-200",
      toastVariants[variant],
      className
    )}
    {...props}
  />
))
Toast.displayName = ToastPrimitive.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitive.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitive.Action
    ref={ref}
    className={cn("text-xs font-medium text-white hover:opacity-90", className)}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitive.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitive.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitive.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitive.Close
    ref={ref}
    className={cn(
      "absolute top-2.5 right-2.5 text-stealth-text-secondary opacity-70 hover:opacity-100",
      "transition-all duration-200 hover:scale-110 active:scale-95",
      "rounded-md p-1 hover:bg-white/10",
      className
    )}
    {...props}
  >
    <X className="h-3.5 w-3.5" />
  </ToastPrimitive.Close>
))
ToastClose.displayName = ToastPrimitive.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitive.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitive.Title
    ref={ref}
    className={cn("font-semibold text-sm text-stealth-primary pr-8", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitive.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitive.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitive.Description
    ref={ref}
    className={cn("text-xs text-stealth-text-secondary opacity-90 mt-1 pr-8", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitive.Description.displayName

export type { ToastProps, ToastVariant }
export {
  ToastProvider,
  ToastViewport,
  Toast,
  ToastAction,
  ToastClose,
  ToastTitle,
  ToastDescription
}

===== END FILE: src\components\ui\toast.tsx =====

===== BEGIN FILE: src\components\ui\tooltip.tsx =====
// src/components/ui/tooltip.tsx

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"
import { cn } from "../../lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 6, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      // Premium stealth tooltip with enhanced glassmorphism
      "tooltip z-[100] overflow-hidden px-3 py-2 text-xs font-medium text-stealth-primary",
      "bg-stealth-card/95 backdrop-blur-md border border-stealth/50",
      "rounded-lg shadow-[0_8px_30px_rgb(0,0,0,0.12)] shadow-stealth/20",
      "animate-in fade-in-0 zoom-in-95 duration-200 ease-out",
      "data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=closed]:duration-150",
      "data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2",
      "data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      "before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-white/5 before:to-transparent before:pointer-events-none",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

===== END FILE: src\components\ui\tooltip.tsx =====

===== BEGIN FILE: src\index.css =====
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    /* Ultra-Modern Stealth Design System - Black/White Only */
    --background: 0 0% 0%; /* Pure black background */
    --foreground: 0 0% 100%; /* Pure white text */
    --card: 0 0% 3%; /* Very dark card background */
    --card-foreground: 0 0% 98%; /* Near-white text on cards */
    --popover: 0 0% 2%; /* Dark popover */
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 100%; /* White primary for contrast */
    --primary-foreground: 0 0% 0%; /* Black text on white */
    --secondary: 0 0% 8%; /* Dark secondary */
    --secondary-foreground: 0 0% 95%;
    --muted: 0 0% 12%; /* Muted dark */
    --muted-foreground: 0 0% 70%; /* Light gray for muted text */
    --accent: 0 0% 15%; /* Accent dark */
    --accent-foreground: 0 0% 95%;
    --destructive: 0 0% 20%; /* Dark destructive */
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 20%; /* Dark borders */
    --input: 0 0% 8%; /* Dark input background */
    --ring: 0 0% 100%; /* White focus ring */
    --radius: 0.75rem;

    /* Stealth Transparency System */
    --stealth-opacity: 0.95; /* Default opacity - adjustable */
    --stealth-bg-primary: rgba(0, 0, 0, var(--stealth-opacity));
    --stealth-bg-secondary: rgba(15, 15, 15, var(--stealth-opacity));
    --stealth-bg-card: rgba(8, 8, 8, var(--stealth-opacity));
    --stealth-border: rgba(255, 255, 255, 0.1);
    --stealth-text-primary: rgba(255, 255, 255, 0.95);
    --stealth-text-secondary: rgba(255, 255, 255, 0.7);
    --stealth-text-muted: rgba(255, 255, 255, 0.5);

    /* Premium Elevation System */
    --elevation-1: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    --elevation-2: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
    --elevation-3: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    --elevation-4: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    --elevation-5: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    --elevation-6: 0 25px 50px -12px rgba(0, 0, 0, 0.25);

    /* Advanced Stealth Glassmorphism - Black/White Only */
    --glass-bg-light: rgba(0, 0, 0, 0.7);
    --glass-bg-medium: rgba(0, 0, 0, 0.8);
    --glass-bg-heavy: rgba(0, 0, 0, 0.9);
    --glass-bg-ultra: rgba(0, 0, 0, var(--stealth-opacity));
    --glass-border-light: rgba(255, 255, 255, 0.08);
    --glass-border-medium: rgba(255, 255, 255, 0.15);
    --glass-border-heavy: rgba(255, 255, 255, 0.25);
    --glass-blur-sm: blur(12px);
    --glass-blur-md: blur(20px);
    --glass-blur-lg: blur(32px);
    --glass-blur-xl: blur(48px);
    --glass-blur-stealth: blur(64px); /* Ultra stealth mode */

    /* Stealth Detection Avoidance */
    --stealth-shadow-light: 0 2px 8px rgba(0, 0, 0, 0.3);
    --stealth-shadow-medium: 0 4px 16px rgba(0, 0, 0, 0.4);
    --stealth-shadow-heavy: 0 8px 32px rgba(0, 0, 0, 0.5);
    --stealth-glow: 0 0 20px rgba(255, 255, 255, 0.1);

    /* Premium Animation System */
    --ease-out-quart: cubic-bezier(0.25, 1, 0.5, 1);
    --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
    --ease-spring: cubic-bezier(0.175, 0.885, 0.32, 1.275);
    --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
    --transition-micro: 100ms var(--ease-out-quart);
    --transition-fast: 200ms var(--ease-out-quart);
    --transition-medium: 300ms var(--ease-out-expo);
    --transition-slow: 500ms var(--ease-out-expo);
    --transition-spring: 400ms var(--ease-spring);

    /* Typography Scale */
    --font-size-xs: 0.75rem;
    --font-size-sm: 0.875rem;
    --font-size-base: 1rem;
    --font-size-lg: 1.125rem;
    --font-size-xl: 1.25rem;
    --font-size-2xl: 1.5rem;
    --font-size-3xl: 1.875rem;
    --font-size-4xl: 2.25rem;

    /* Spacing System */
    --space-px: 1px;
    --space-0: 0;
    --space-1: 0.25rem;
    --space-2: 0.5rem;
    --space-3: 0.75rem;
    --space-4: 1rem;
    --space-5: 1.25rem;
    --space-6: 1.5rem;
    --space-8: 2rem;
    --space-10: 2.5rem;
    --space-12: 3rem;
    --space-16: 4rem;
    --space-20: 5rem;
    --space-24: 6rem;
    --space-32: 8rem;

    /* Interactive States */
    --hover-lift: translateY(-1px);
    --hover-scale: scale(1.02);
    --active-scale: scale(0.98);
    --focus-ring: 0 0 0 3px rgba(0, 0, 0, 0.1);
  }

  /* Stealth mode is always dark - no light mode for stealth operations */
  .light {
    /* Force stealth mode even if light mode is requested */
    --background: 0 0% 0%;
    --foreground: 0 0% 100%;
    --card: 0 0% 3%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 2%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 100%;
    --primary-foreground: 0 0% 0%;
    --secondary: 0 0% 8%;
    --secondary-foreground: 0 0% 95%;
    --muted: 0 0% 12%;
    --muted-foreground: 0 0% 70%;
    --accent: 0 0% 15%;
    --accent-foreground: 0 0% 95%;
    --border: 0 0% 20%;
    --input: 0 0% 8%;
    --ring: 0 0% 100%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  
  html, body, #root, #app {
    background: transparent !important;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
    color: var(--stealth-text-primary);
    /* Stealth mode - undetectable by screen sharing */
    will-change: opacity;
    transition: opacity 0.2s ease-out;
  }
  
  body {
    @apply antialiased;
    background: transparent !important;
    color: var(--stealth-text-primary);
    font-feature-settings: "cv02", "cv03", "cv04", "cv11";
    font-variation-settings: "opsz" 32;
    font-optical-sizing: auto;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
    /* Enhanced stealth properties */
    -webkit-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
  }

  /* Stealth Mode Classes */
  .stealth-mode {
    opacity: var(--stealth-opacity) !important;
    transition: opacity 0.3s ease-out;
  }

  .stealth-invisible {
    opacity: 0 !important;
    pointer-events: none;
  }

  .stealth-ultra {
    opacity: 0.1 !important;
    filter: blur(1px);
  }
  
  /* Stealth scrollbar styling - Undetectable */
  ::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }
  
  ::-webkit-scrollbar-track {
    background: transparent;
  }
  
  ::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
    border: 1px solid transparent;
    background-clip: content-box;
  }
  
  ::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.2);
    background-clip: content-box;
  }
  
  ::-webkit-scrollbar-corner {
    background: transparent;
  }

  /* Hide scrollbars in stealth mode */
  .stealth-mode::-webkit-scrollbar {
    display: none;
  }

  .stealth-mode {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
}

@layer components {
  /* Stealth Overrides: bind Tailwind token classes to stealth variables */
  .bg-card { background-color: var(--stealth-bg-card) !important; }
  .bg-background { background-color: var(--stealth-bg-primary) !important; }
  .bg-secondary { background-color: var(--stealth-bg-secondary) !important; }
  .bg-popover { background-color: var(--stealth-bg-card) !important; }
  .border-border { border-color: var(--stealth-border) !important; }
  .text-foreground { color: var(--stealth-text-primary) !important; }
  .text-muted-foreground { color: var(--stealth-text-muted) !important; }

  /* Textareas: match input-premium style and white text */
  textarea.input-premium,
  textarea.stealth-textarea {
    @apply h-24 rounded-lg px-3 py-2 text-sm font-normal;
    background: var(--stealth-bg-card);
    border: 1px solid var(--stealth-border);
    color: var(--stealth-text-primary);
    backdrop-filter: var(--glass-blur-sm);
    -webkit-backdrop-filter: var(--glass-blur-sm);
    box-shadow: var(--stealth-shadow-light);
  }

  textarea.input-premium::placeholder,
  textarea.stealth-textarea::placeholder {
    color: var(--stealth-text-muted);
  }
  /* Ultra-Modern Stealth Button System */
  .btn-premium {
    @apply relative inline-flex items-center justify-center gap-2 rounded-xl text-sm font-semibold;
    @apply transition-all duration-200 ease-out;
    @apply focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-white/50;
    @apply disabled:pointer-events-none disabled:opacity-30;
    @apply overflow-hidden;
    background: var(--stealth-bg-secondary);
    border: 1px solid var(--stealth-border);
    color: var(--stealth-text-primary);
    box-shadow: var(--stealth-shadow-light);
    backdrop-filter: var(--glass-blur-sm);
    -webkit-backdrop-filter: var(--glass-blur-sm);
    transform: translateZ(0);
  }
  
  .btn-premium::before {
    content: '';
    @apply absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent;
    @apply translate-x-[-100%] transition-transform duration-500 ease-out;
  }
  
  .btn-premium:hover::before {
    @apply translate-x-[100%];
  }
  
  .btn-premium:hover {
    transform: var(--hover-lift);
    box-shadow: var(--elevation-4);
  }
  
  .btn-premium:active {
    transform: var(--active-scale);
    transition-duration: 75ms;
  }
  
  /* Stealth Primary Button */
  .btn-primary {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.95) 100%);
    color: rgba(0, 0, 0, 0.9);
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: var(--stealth-shadow-medium), var(--stealth-glow);
  }
  
  .btn-primary:hover {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 1) 100%);
    box-shadow: var(--stealth-shadow-heavy), var(--stealth-glow);
    transform: translateY(-1px);
  }
  
  /* Stealth Secondary Button */
  .btn-secondary {
    background: var(--stealth-bg-card);
    color: var(--stealth-text-primary);
    border: 1px solid var(--stealth-border);
    backdrop-filter: var(--glass-blur-sm);
    -webkit-backdrop-filter: var(--glass-blur-sm);
  }
  
  .btn-secondary:hover {
    background: var(--stealth-bg-secondary);
    border-color: rgba(255, 255, 255, 0.2);
    box-shadow: var(--stealth-shadow-medium);
  }
  
  /* Stealth Ghost Button */
  .btn-ghost {
    background: transparent;
    color: var(--stealth-text-secondary);
    border: 1px solid transparent;
    box-shadow: none;
  }
  
  .btn-ghost:hover {
    background: var(--glass-bg-light);
    color: var(--stealth-text-primary);
    border-color: var(--stealth-border);
    backdrop-filter: var(--glass-blur-sm);
    -webkit-backdrop-filter: var(--glass-blur-sm);
    box-shadow: var(--stealth-shadow-light);
  }
  
  /* Outline Button */
  .btn-outline {
    @apply bg-background text-foreground border border-border;
  }
  
  .btn-outline:hover {
    @apply bg-secondary/30;
  }
  
  /* Button Sizes - Sleeker */
  .btn-sm {
    @apply h-7 px-2.5 text-xs rounded-md;
  }
  
  .btn-md {
    @apply h-8 px-3 text-sm rounded-lg;
  }
  
  .btn-lg {
    @apply h-9 px-4 text-sm rounded-lg;
  }
  
  .btn-xl {
    @apply h-10 px-5 text-base rounded-xl;
  }

  /* Legacy compatibility */
  .btn { @apply btn-premium btn-primary btn-md; }
  .btn-default { @apply btn-premium btn-primary btn-md; }
  .button { @apply btn-premium btn-primary btn-md; }
  .button-primary { @apply btn-premium btn-primary btn-md; }
  .button-secondary { @apply btn-premium btn-secondary btn-md; }
  .button-ghost { @apply btn-premium btn-ghost btn-md; }

  /* Ultra-Modern Stealth Card System */
  .card-premium {
    @apply relative rounded-xl;
    @apply transition-all duration-200 ease-out;
    @apply overflow-hidden;
    /* Bind to stealth opacity so Settings slider affects all cards */
    background: var(--stealth-bg-card);
    border: 1px solid var(--stealth-border);
    color: var(--stealth-text-primary);
    box-shadow: var(--stealth-shadow-light);
    backdrop-filter: var(--glass-blur-md);
    -webkit-backdrop-filter: var(--glass-blur-md);
  }
  
  .card-premium::before {
    content: '';
    @apply absolute inset-0 pointer-events-none;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.03) 0%, transparent 50%);
  }
  
  .card-premium:hover {
    box-shadow: var(--stealth-shadow-medium);
    border-color: rgba(255, 255, 255, 0.15);
    transform: translateY(-1px);
  }
  
  .card-glass {
    @apply card-premium;
    background: var(--glass-bg-medium);
    border: 1px solid var(--glass-border-medium);
    backdrop-filter: var(--glass-blur-lg);
    -webkit-backdrop-filter: var(--glass-blur-lg);
  }
  
  .card-elevated {
    @apply card-premium;
    box-shadow: var(--stealth-shadow-heavy);
    border-color: rgba(255, 255, 255, 0.2);
  }
  
  .card-floating {
    @apply card-premium;
    box-shadow: var(--stealth-shadow-heavy), var(--stealth-glow);
    border: 1px solid rgba(255, 255, 255, 0.1);
    backdrop-filter: var(--glass-blur-xl);
    -webkit-backdrop-filter: var(--glass-blur-xl);
  }

  /* Legacy compatibility */
  .card {
    @apply card-premium;
  }

  /* Ultra-Modern Stealth Floating Toolbar */
  .floating-toolbar {
    @apply px-2 py-1.5 transition-all duration-200 ease-out;
    background: var(--glass-bg-ultra);
    border: 1px solid var(--glass-border-medium);
    border-radius: 1rem;
    box-shadow: var(--stealth-shadow-heavy), var(--stealth-glow);
    backdrop-filter: var(--glass-blur-xl);
    -webkit-backdrop-filter: var(--glass-blur-xl);
    pointer-events: auto;
  }

  .floating-toolbar:hover {
    background: var(--glass-bg-ultra);
    /* Keep position fixed on hover: no slide */
    transform: none;
    border-color: var(--glass-border-medium);
    box-shadow: var(--stealth-shadow-heavy), var(--stealth-glow);
    backdrop-filter: var(--glass-blur-xl);
    -webkit-backdrop-filter: var(--glass-blur-xl);
  }
  
  /* Ultra-Modern Stealth Toolbar Button */
  .toolbar-btn {
    @apply relative flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs font-medium;
    @apply transition-all duration-150 ease-out overflow-hidden;
    /* Default to the hovered visual style so buttons look "perfect" without hover */
    color: var(--stealth-text-primary);
    background: var(--glass-bg-light);
    border: 1px solid var(--glass-border-light);
    backdrop-filter: var(--glass-blur-sm);
    -webkit-backdrop-filter: var(--glass-blur-sm);
  }

  .toolbar-btn:hover {
    /* Keep a consistent look on hover; avoid layout shifts */
    color: var(--stealth-text-primary);
    background: var(--glass-bg-light);
    border-color: var(--glass-border-light);
    backdrop-filter: var(--glass-blur-sm);
    -webkit-backdrop-filter: var(--glass-blur-sm);
    transform: none;
  }

  .toolbar-btn:active {
    transform: scale(0.95);
  }
  
  .toolbar-btn::before {
    content: '';
    @apply absolute inset-0;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.05), transparent);
    transform: translateX(-100%);
    transition: transform 0.5s ease-out;
  }
  
  .toolbar-btn:hover::before {
    transform: translateX(100%);
  }
  
  .toolbar-btn-active {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.95));
    color: rgba(0, 0, 0, 0.9);
    border-color: rgba(255, 255, 255, 0.3);
    box-shadow: var(--stealth-shadow-medium), var(--stealth-glow);
  }
  
  .toolbar-btn-active:hover {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 1));
    box-shadow: var(--stealth-shadow-heavy), var(--stealth-glow);
  }

  /* Voice button active state - maintains dark theme */
  .toolbar-btn-voice-active {
    background: var(--glass-bg-light);
    color: var(--stealth-text-primary);
    border: 1px solid transparent;
    box-shadow: var(--stealth-shadow-medium), var(--stealth-glow);
  }

  .toolbar-btn-voice-active:hover {
    background: var(--glass-bg-light);
    border: 1px solid transparent;
    box-shadow: var(--stealth-shadow-medium), var(--stealth-glow);
  }

  .toolbar-btn-voice-active .icon-container {
    background: rgba(255, 255, 255, 0.15);
  }

  .toolbar-btn-voice-active:hover .icon-container {
    background: rgba(255, 255, 255, 0.15);
  }

  /* Premium Live Mode Button */
  .live-mode-btn {
    @apply relative flex flex-col items-center justify-center gap-1 px-3 py-3 rounded-lg text-xs font-semibold;
    /* Only animate transform and shadow to avoid fast border/background flicker */
    transition-property: transform, box-shadow;
    transition-duration: 600ms;
    transition-timing-function: var(--ease-out-expo);
    will-change: transform, box-shadow;
    min-width: 88px;
    color: var(--stealth-text-primary);
    background: var(--glass-bg-ultra);
    border: 1px solid var(--glass-border-medium);
    box-shadow: var(--stealth-shadow-heavy), var(--stealth-glow);
    backdrop-filter: var(--glass-blur-xl);
    -webkit-backdrop-filter: var(--glass-blur-xl);
  }

  .live-mode-btn:hover {
    transform: translateY(-0.5px);
    box-shadow: var(--stealth-shadow-heavy), var(--stealth-glow);
    /* Keep same visuals on hover to avoid fast UI changes */
    background: var(--glass-bg-ultra);
    border-color: var(--glass-border-medium);
  }

  .live-mode-icon {
    @apply w-4 h-4 flex items-center justify-center rounded-md;
    background: rgba(255, 255, 255, 0.12);
  }

  .live-mode-label {
    font-size: 11px;
    letter-spacing: 0.1px;
  }

  /* Subtle, smooth breathing glow animation for primary action */
  

  .live-mode-breathing {
    animation: liveModeBreathing 60s ease-in-out infinite;
  }

  /* Ultra-Modern Stealth Icon Container */
  .icon-container {
    @apply w-4 h-4 flex items-center justify-center rounded-md;
    /* Match hover brightness by default */
    background: rgba(255, 255, 255, 0.1);
    transition: all 0.15s ease-out;
  }
  
  .toolbar-btn:hover .icon-container {
    background: rgba(255, 255, 255, 0.1);
  }
  
  .toolbar-btn-active .icon-container {
    background: rgba(0, 0, 0, 0.1);
  }

  /* App-region utilities for Electron draggable areas */
  .app-region-drag { -webkit-app-region: drag; cursor: move; }
  .app-region-no-drag { -webkit-app-region: no-drag; }

  /* Premium Tooltip - Apple/Microsoft Inspired */
  .tooltip {
    @apply bg-primary text-primary-foreground rounded-xl px-3 py-2 text-xs font-medium;
    box-shadow: var(--elevation-4);
    backdrop-filter: var(--glass-blur-sm);
    -webkit-backdrop-filter: var(--glass-blur-sm);
    animation: tooltipFadeIn 200ms var(--ease-out-expo);
  }
  
  /* Premium Separator */
  .separator {
    @apply w-px h-6 bg-gradient-to-b from-transparent via-border to-transparent mx-3;
  }

  /* Ultra-Modern Stealth Input System */
  .input-premium {
    @apply flex h-9 w-full rounded-lg px-3 py-2 text-sm font-normal;
    @apply disabled:cursor-not-allowed disabled:opacity-30;
    @apply transition-all duration-150 ease-out;
    background: var(--stealth-bg-card);
    border: 1px solid var(--stealth-border);
    color: var(--stealth-text-primary);
    backdrop-filter: var(--glass-blur-sm);
    -webkit-backdrop-filter: var(--glass-blur-sm);
    box-shadow: var(--stealth-shadow-light);
  }

  /* Make native <select> controls transparent like inputs */
  select.input-premium {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    background: var(--stealth-bg-card) no-repeat right 8px center;
    background-size: 12px 12px;
    /* Optional minimal chevron (white) */
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 20 20' fill='none'%3E%3Cpath d='M6 8l4 4 4-4' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
    padding-right: 28px; /* room for chevron */
  }

  select.input-premium::-ms-expand { display: none; }

  select.input-premium:focus-visible {
    outline: none;
    border-color: rgba(255, 255, 255, 0.3);
    box-shadow: var(--stealth-shadow-medium), 0 0 0 1px rgba(255, 255, 255, 0.1);
  }

  select.input-premium:hover:not(:focus) {
    border-color: rgba(255, 255, 255, 0.2);
    box-shadow: var(--stealth-shadow-medium);
  }

  /* Improve popup option contrast in dark theme (not all UAs honor transparency here) */
  select.input-premium option {
    background-color: rgba(10, 10, 10, 0.96);
    color: var(--stealth-text-primary);
  }

  .input-premium::placeholder {
    color: var(--stealth-text-muted);
    font-weight: normal;
  }

  .input-premium:focus-visible {
    outline: none;
    border-color: rgba(255, 255, 255, 0.3);
    box-shadow: var(--stealth-shadow-medium), 0 0 0 1px rgba(255, 255, 255, 0.1);
  }
  
  .input-premium:focus {
    border-color: rgba(255, 255, 255, 0.4);
    box-shadow: var(--stealth-shadow-medium), 0 0 0 1px rgba(255, 255, 255, 0.15);
    transform: translateY(-0.5px);
  }
  
  .input-premium:hover:not(:focus) {
    border-color: rgba(255, 255, 255, 0.2);
    box-shadow: var(--stealth-shadow-medium);
  }

  /* Legacy compatibility */
  .input {
    @apply input-premium;
  }

  /* Stealth Recording Animation - Ultra Modern */
  .recording-pulse {
    animation: stealthRecordingPulse 2s ease-in-out infinite;
  }
  
  @keyframes stealthRecordingPulse {
    0%, 100% { 
      box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7);
      background-color: rgba(255, 255, 255, 0.9);
      transform: scale(1);
    }
    50% { 
      box-shadow: 0 0 0 8px rgba(255, 255, 255, 0);
      background-color: rgba(255, 255, 255, 1);
      transform: scale(1.05);
    }
  }

  /* Advanced Micro-interactions - Apple/Microsoft Inspired */
  .hover-lift {
    @apply transition-all duration-300 ease-out;
    will-change: transform, box-shadow;
  }
  
  .hover-lift:hover {
    transform: var(--hover-lift);
    box-shadow: var(--elevation-4);
  }
  
  .hover-scale {
    @apply transition-transform duration-200 ease-out;
    will-change: transform;
  }
  
  .hover-scale:hover {
    transform: var(--hover-scale);
  }
  
  .press-down {
    @apply active:scale-95 transition-transform duration-75;
    transition-timing-function: var(--ease-out-quart);
  }
  
  .spring-bounce {
    @apply transition-transform;
    transition-duration: 400ms;
    transition-timing-function: var(--ease-spring);
  }
  
  .spring-bounce:hover {
    transform: scale(1.05);
  }
  
  .spring-bounce:active {
    transform: scale(0.95);
    transition-duration: 100ms;
  }

  /* Premium Focus States */
  .focus-ring {
    @apply focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2;
    @apply transition-all duration-200 ease-out;
  }
  
  .focus-glow {
    @apply focus-visible:outline-none;
    transition: all 200ms var(--ease-out-expo);
  }
  
  .focus-glow:focus-visible {
    box-shadow: var(--elevation-3), 0 0 0 3px rgba(0, 0, 0, 0.1);
  }






  /* Responsive Design System */
  @media (max-width: 768px) {
    .floating-toolbar {
      @apply px-3 py-2 rounded-xl;
    }
    
    .toolbar-btn {
      @apply w-8 h-8 p-1;
    }
    
    .tooltip {
      @apply min-w-[240px] text-xs;
    }
  }

  @media (max-width: 480px) {
    .floating-toolbar {
      @apply top-2 px-2 py-1;
    }
    
    .card {
      @apply mx-2 rounded-xl;
    }
  }

  /* Background Effects */
  .bg-mesh {
    background-image: 
      radial-gradient(circle at 25% 25%, rgba(0, 0, 0, 0.02) 0%, transparent 50%),
      radial-gradient(circle at 75% 75%, rgba(0, 0, 0, 0.02) 0%, transparent 50%);
  }
  
  /* Loading States */
  .loading-shimmer {
    background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.04), transparent);
    background-size: 200% 100%;
    animation: shimmer 2s infinite;
  }
  
  @keyframes shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
  }

  /* Smooth command entry animation */
  @keyframes cmdEnter {
    0% { opacity: 0; transform: translateY(6px) scale(0.98); }
    100% { opacity: 1; transform: translateY(0) scale(1); }
  }

  .animate-cmd-enter {
    animation: cmdEnter 220ms var(--ease-out-expo) both;
    will-change: opacity, transform;
  }





}

/* Ultra-Modern Stealth Chat Messages */
.message {
  border-radius: 12px;
  padding: 12px 16px;
  margin-bottom: 8px;
  max-width: 80%;
  font-size: 14px;
  line-height: 1.5;
  backdrop-filter: var(--glass-blur-sm);
  -webkit-backdrop-filter: var(--glass-blur-sm);
  border: 1px solid var(--stealth-border);
}

.message-user {
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.95));
  color: rgba(0, 0, 0, 0.9);
  margin-left: auto;
  box-shadow: var(--stealth-shadow-light);
}

.message-assistant {
  background: var(--stealth-bg-card);
  color: var(--stealth-text-primary);
  margin-right: auto;
  border-color: var(--glass-border-light);
  box-shadow: var(--stealth-shadow-light);
}

/* Stealth Loading Animation */
.loading {
  display: inline-flex;
  gap: 4px;
}

.loading-dot {
  width: 4px;
  height: 4px;
  border-radius: 50%;
  background: var(--stealth-text-primary);
  animation: stealthLoadingBounce 1.4s ease-in-out infinite both;
}

.loading-dot:nth-child(1) { animation-delay: -0.32s; }
.loading-dot:nth-child(2) { animation-delay: -0.16s; }
.loading-dot:nth-child(3) { animation-delay: 0s; }

@keyframes stealthLoadingBounce {
  0%, 80%, 100% { 
    transform: scale(0.8); 
    opacity: 0.3;
    background: var(--stealth-text-muted);
  }
  40% { 
    transform: scale(1); 
    opacity: 1;
    background: var(--stealth-text-primary);
  }
}

/* Ultra-Modern Stealth Command Bar */
.command-bar {
  background: var(--glass-bg-ultra);
  backdrop-filter: var(--glass-blur-xl);
  -webkit-backdrop-filter: var(--glass-blur-xl);
  border: 1px solid var(--glass-border-medium);
  border-radius: 16px;
  box-shadow: var(--stealth-shadow-heavy), var(--stealth-glow);
  transition: all 0.2s ease-out;
  padding: 12px 20px;
}

/* Draggable Area */
.draggable-area {
  -webkit-app-region: drag;
  cursor: move;
}

button, input, select, textarea, .interactive {
  -webkit-app-region: no-drag;
}

/* Ultra-Modern Stealth Tooltip */
.tooltip {
  background: var(--stealth-bg-primary);
  color: var(--stealth-text-primary);
  border: 1px solid var(--stealth-border);
  border-radius: 10px;
  padding: 8px 12px;
  font-size: 12px;
  font-weight: 500;
  box-shadow: var(--stealth-shadow-heavy), var(--stealth-glow);
  backdrop-filter: var(--glass-blur-md);
  -webkit-backdrop-filter: var(--glass-blur-md);
  animation: stealthTooltipFadeIn 0.2s ease-out;
}

@keyframes stealthTooltipFadeIn {
  from {
    opacity: 0;
    transform: translateY(4px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* Ultra-Modern Stealth Status Badge */
.badge {
  display: inline-flex;
  align-items: center;
  border-radius: 8px;
  padding: 4px 10px;
  font-size: 11px;
  font-weight: 600;
  transition: all 0.2s ease-out;
  backdrop-filter: var(--glass-blur-sm);
  -webkit-backdrop-filter: var(--glass-blur-sm);
}

.badge-default {
  background: var(--stealth-bg-card);
  color: var(--stealth-text-primary);
  border: 1px solid var(--stealth-border);
}

.badge-outline {
  background: transparent;
  color: var(--stealth-text-secondary);
  border: 1px solid var(--stealth-border);
}

.badge-outline:hover {
  background: var(--glass-bg-light);
  color: var(--stealth-text-primary);
  border-color: var(--glass-border-medium);
}

/* Ultra-Modern Stealth Slider */
.stealth-slider {
  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  cursor: pointer;
}

.stealth-slider::-webkit-slider-track {
  background: var(--stealth-bg-secondary);
  height: 6px;
  border-radius: 3px;
  border: 1px solid var(--stealth-border);
}

.stealth-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  height: 16px;
  width: 16px;
  border-radius: 50%;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 1));
  border: 2px solid var(--stealth-border);
  cursor: pointer;
  box-shadow: var(--stealth-shadow-medium);
  transition: all 0.2s ease-out;
}

.stealth-slider::-webkit-slider-thumb:hover {
  background: linear-gradient(135deg, rgba(255, 255, 255, 1), rgba(255, 255, 255, 1));
  box-shadow: var(--stealth-shadow-heavy), var(--stealth-glow);
  transform: scale(1.1);
}

.stealth-slider::-moz-range-track {
  background: var(--stealth-bg-secondary);
  height: 6px;
  border-radius: 3px;
  border: 1px solid var(--stealth-border);
}

.stealth-slider::-moz-range-thumb {
  height: 16px;
  width: 16px;
  border-radius: 50%;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 1));
  border: 2px solid var(--stealth-border);
  cursor: pointer;
  box-shadow: var(--stealth-shadow-medium);
  transition: all 0.2s ease-out;
}

.stealth-slider::-moz-range-thumb:hover {
  background: linear-gradient(135deg, rgba(255, 255, 255, 1), rgba(255, 255, 255, 1));
  box-shadow: var(--stealth-shadow-heavy), var(--stealth-glow);
  transform: scale(1.1);
}

/* Stealth Text Color Utilities */
.text-stealth-primary {
  color: var(--stealth-text-primary);
}

.text-stealth-secondary {
  color: var(--stealth-text-secondary);
}

.text-stealth-muted {
  color: var(--stealth-text-muted);
}

.bg-stealth-primary {
  background-color: var(--stealth-bg-primary);
}

.bg-stealth-secondary {
  background-color: var(--stealth-bg-secondary);
}

.bg-stealth-card {
  background-color: var(--stealth-bg-card);
}

.border-stealth {
  border-color: var(--stealth-border);
}

/* Emergency Hide Animation */
@keyframes emergencyHide {
  0% { opacity: 1; transform: scale(1); }
  100% { opacity: 0; transform: scale(0.8); }
}

.emergency-hide {
  animation: emergencyHide 0.3s ease-out forwards;
}

/* Screen Share Detection Avoidance */
.undetectable {
  filter: contrast(0.95) brightness(0.98);
  -webkit-filter: contrast(0.95) brightness(0.98);
}

/* Global Scrollbar Suppression (keep scroll functionality, hide bars) */
html, body, #root, #app {
  -ms-overflow-style: none; /* IE and Edge */
  scrollbar-width: none; /* Firefox */
}

/* Hide WebKit scrollbars globally */
html::-webkit-scrollbar,
body::-webkit-scrollbar,
#root::-webkit-scrollbar,
#app::-webkit-scrollbar,
*::-webkit-scrollbar {
  display: none !important;
  width: 0 !important;
  height: 0 !important;
  background: transparent !important;
}

/* Ultra-Modern Focus States for Stealth */
.stealth-focus:focus-visible {
  outline: none;
  box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.2);
  border-color: rgba(255, 255, 255, 0.4);
}

===== END FILE: src\index.css =====

===== BEGIN FILE: src\lib\utils.ts =====
// src/lib/utils.ts

export function cn(...classes: (string | undefined)[]) {
  return classes.filter(Boolean).join(" ")
}

===== END FILE: src\lib\utils.ts =====

===== BEGIN FILE: src\lib\wav.ts =====
// Simple WAV encoder for Float32 PCM -> 16-bit PCM WAV base64
export function floatTo16BitPCM(float32: Float32Array): Int16Array {
  const buffer = new Int16Array(float32.length)
  for (let i = 0; i < float32.length; i++) {
    let s = Math.max(-1, Math.min(1, float32[i]))
    buffer[i] = s < 0 ? s * 0x8000 : s * 0x7fff
  }
  return buffer
}

function writeString(view: DataView, offset: number, str: string) {
  for (let i = 0; i < str.length; i++) {
    view.setUint8(offset + i, str.charCodeAt(i))
  }
}

export function encodeWavBase64(channels: Float32Array[], sampleRate: number): string {
  const numChannels = channels.length
  const numFrames = channels[0]?.length || 0

  // Interleave if stereo; for mono, just that channel
  let interleaved: Float32Array
  if (numChannels === 1) {
    interleaved = channels[0]
  } else {
    interleaved = new Float32Array(numFrames * numChannels)
    for (let i = 0; i < numFrames; i++) {
      for (let ch = 0; ch < numChannels; ch++) {
        interleaved[i * numChannels + ch] = channels[ch][i]
      }
    }
  }

  const pcm16 = floatTo16BitPCM(interleaved)
  const blockAlign = numChannels * 2 // 16-bit
  const byteRate = sampleRate * blockAlign
  const dataSize = pcm16.length * 2

  const buffer = new ArrayBuffer(44 + dataSize)
  const view = new DataView(buffer)

  // RIFF header
  writeString(view, 0, 'RIFF')
  view.setUint32(4, 36 + dataSize, true)
  writeString(view, 8, 'WAVE')

  // fmt chunk
  writeString(view, 12, 'fmt ')
  view.setUint32(16, 16, true) // PCM
  view.setUint16(20, 1, true) // Linear PCM
  view.setUint16(22, numChannels, true)
  view.setUint32(24, sampleRate, true)
  view.setUint32(28, byteRate, true)
  view.setUint16(32, blockAlign, true)
  view.setUint16(34, 16, true) // bits per sample

  // data chunk
  writeString(view, 36, 'data')
  view.setUint32(40, dataSize, true)

  // PCM data
  let offset = 44
  for (let i = 0; i < pcm16.length; i++, offset += 2) {
    view.setInt16(offset, pcm16[i], true)
  }

  // Convert to base64
  const bytes = new Uint8Array(buffer)
  let binary = ''
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i])
  }
  return btoa(binary)
}

===== END FILE: src\lib\wav.ts =====

===== BEGIN FILE: src\main.tsx =====
import React from "react"
import ReactDOM from "react-dom/client"
import App from "./App"
import "./index.css"

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)

===== END FILE: src\main.tsx =====

===== BEGIN FILE: src\types\audio.ts =====
export interface AudioResult {
  text: string;
  timestamp: number;
} 
===== END FILE: src\types\audio.ts =====

===== BEGIN FILE: src\types\electron.d.ts =====
export interface ElectronAPI {
  updateContentDimensions: (dimensions: {
    width: number
    height: number
  }) => Promise<void>
  getScreenshots: () => Promise<Array<{ path: string; preview: string }>>
  deleteScreenshot: (path: string) => Promise<{ success: boolean; error?: string }>
  onScreenshotTaken: (callback: (data: { path: string; preview: string }) => void) => () => void
  onSolutionsReady: (callback: (solutions: string) => void) => () => void
  onResetView: (callback: () => void) => () => void
  onSolutionStart: (callback: () => void) => () => void
  onDebugStart: (callback: () => void) => () => void
  onDebugSuccess: (callback: (data: any) => void) => () => void
  onSolutionError: (callback: (error: string) => void) => () => void
  onProcessingNoScreenshots: (callback: () => void) => () => void
  onProblemExtracted: (callback: (data: any) => void) => () => void
  onSolutionSuccess: (callback: (data: any) => void) => () => void
  onUnauthorized: (callback: () => void) => () => void
  onDebugError: (callback: (error: string) => void) => () => void
  takeScreenshot: () => Promise<{ path: string; preview: string }>
  moveWindowLeft: () => Promise<void>
  moveWindowRight: () => Promise<void>
  moveWindowUp: () => Promise<void>
  moveWindowDown: () => Promise<void>
  analyzeAudioFromBase64: (data: string, mimeType: string) => Promise<{ text: string; timestamp: number }>
  analyzeAudioFile: (path: string) => Promise<{ text: string; timestamp: number }>
  analyzeImageFile: (path: string) => Promise<{ text: string; timestamp: number } | any>
  quitApp: () => Promise<void>
  // LLM Model Management
  getCurrentLlmConfig: () => Promise<{ provider: "ollama" | "gemini"; model: string; isOllama: boolean }>
  getAvailableOllamaModels: () => Promise<string[]>
  switchToOllama: (model?: string, url?: string) => Promise<{ success: boolean; error?: string }>
  switchToGemini: (apiKey?: string) => Promise<{ success: boolean; error?: string }>
  testLlmConnection: () => Promise<{ success: boolean; error?: string }>
  // Generic invoker
  invoke: (channel: string, ...args: any[]) => Promise<any>

  // Live transcript + commands
  startLiveTranscript: () => Promise<{ success: boolean; error?: string }>
  stopLiveTranscript: () => Promise<{ success: boolean; error?: string }>
  sendTranscriptChunk: (id: string, base64Wav: string) => Promise<{ id: string; text: string; words?: { word: string; start: number; end: number }[] }>
  extractCommands: (utterance: string, timestampISO?: string) => Promise<any[] | null>
  polishCommandResponse: (commandText: string, context: { transcriptWindow: string; timestamp: string; who: string }) => Promise<{ text: string }>

  // Native loopback (WASAPI) transcription 
  startLoopbackTranscript: (options?: { model?: string; engine?: string }) => Promise<{ success: boolean; error?: string }>
  stopLoopbackTranscript: () => Promise<void>
  onLoopbackTranscript: (callback: (data: { text: string; timestamp: number; confidence?: number }) => void) => () => void
  onLoopbackStatus: (callback: (message: string) => void) => () => void
  onLoopbackFallback: (callback: (data: { originalModel: string; fallbackModel: string; message: string }) => void) => () => void
  onLoopbackError: (callback: (error: string) => void) => () => void
  getLoopbackModel: () => Promise<{ model: string; engine: string; isReady: boolean }>

  // Deepgram transcription
  startDeepgramTranscript: (options?: { model?: string }) => Promise<{ success: boolean; error?: string; model?: string; engine?: string }>
  stopDeepgramTranscript: () => Promise<{ success: boolean; error?: string }>
  getDeepgramModel: () => Promise<{ model: string; engine: string; isReady: boolean; hasApiKey: boolean }>
  onDeepgramTranscript: (callback: (data: { text: string; timestamp: number; confidence?: number }) => void) => () => void
  onDeepgramStatus: (callback: (message: string) => void) => () => void
  onDeepgramReady: (callback: (data: { model: string; engine: string }) => void) => () => void
  onDeepgramError: (callback: (error: string) => void) => () => void

  // Licensing
  getLicenseStatus: () => Promise<{ deviceId: string; status: "active"|"expired"|"banned"|"unknown"; trialEndISO: string|null; serverTimeISO: string|null; daysLeft: number; offline: boolean; message?: string }>
  forceVerifyLicense: () => Promise<{ deviceId: string; status: "active"|"expired"|"banned"|"unknown"; trialEndISO: string|null; serverTimeISO: string|null; daysLeft: number; offline: boolean; message?: string }>

  // Mode management
   // Mode management
   // Mode management
    // Mode management
  // Mode management
  onModeChange: (callback: (mode: 'live' | 'voice' | 'chat' | 'settings') => void) => () => void;
  changeMode: (mode: 'live' | 'voice' | 'chat' | 'settings') => void;
  toggleApp: () => Promise<void>;
  onStealthCycle: (callback: () => void) => () => void;
  onEmergencyHide: (callback: () => void) => () => void;
  // Visibility/content protection indicator
  onContentProtectionChanged: (callback: (enabled: boolean) => void) => () => void;
  onWindowVisibilityChanged: (callback: (visible: boolean) => void) => () => void;
  getMode: () => Promise<'live' | 'voice' | 'chat' | 'settings'>;
  isMode: (mode: 'live' | 'voice' | 'chat' | 'settings') => Promise<boolean>;
  getModeHistory: () => Promise<Array<'live' | 'voice' | 'chat' | 'settings'>>;
  setModeHistory: (modes: Array<'live' | 'voice' | 'chat' | 'settings'>) => Promise<void>;
  resetModeHistory: () => Promise<void>;
  getPreviousMode: () => Promise<'live' | 'voice' | 'chat' | 'settings' | null>;
  getNextMode: () => Promise<'live' | 'voice' | 'chat' | 'settings' | null>;
}

declare global {
  interface Window {
    electronAPI: ElectronAPI
  }
} 
===== END FILE: src\types\electron.d.ts =====

===== BEGIN FILE: src\types\global.d.ts =====
 
===== END FILE: src\types\global.d.ts =====

===== BEGIN FILE: src\types\index.tsx =====
export interface Screenshot {
  id: string
  path: string
  timestamp: number
  thumbnail: string // Base64 thumbnail
}

export interface Solution {
  initial_thoughts: string[]
  thought_steps: string[]
  description: string
  code: string
}

===== END FILE: src\types\index.tsx =====

===== BEGIN FILE: src\types\solutions.ts =====
export interface Solution {
  initial_thoughts: string[]
  thought_steps: string[]
  description: string
  code: string
}

export interface SolutionsResponse {
  [key: string]: Solution
}

export interface ProblemStatementData {
  problem_statement: string;
  input_format: {
    description: string;
    parameters: any[];
  };
  output_format: {
    description: string;
    type: string;
    subtype: string;
  };
  complexity: {
    time: string;
    space: string;
  };
  test_cases: any[];
  validation_type: string;
  difficulty: string;
}
===== END FILE: src\types\solutions.ts =====

===== BEGIN FILE: src\vite-env.d.ts =====
/// <reference types="vite/client" />

===== END FILE: src\vite-env.d.ts =====

